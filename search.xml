<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>&lt;1984&gt;-读后感</title>
      <link href="/archives/987f19d8.html"/>
      <url>/archives/987f19d8.html</url>
      
        <content type="html"><![CDATA[<p>​      每天抽了点时间，算是读完了《1984》这本书吧，虽然并不是看的很明白，但是那种“专制独裁”的模样确实能够记得，温斯顿所在的那个世界之中，一切都是被监视的，等级秩序十分的鲜明，内党成员，外党成员，无产阶级，看似营造了一个“共产主义”的世界，但是那个世界里，一切都是相反的，爱与和平变成了仇恨与战争，奴役变成了自由，哪怕是人的思想都变得不在属于个体，而是属于一个存在亦或是不存在的”老大哥”，整个社会的基调及其的阴暗。</p><p>​      在这种情况下，温斯顿在后期经历了很多的非人折磨，那些折磨的手段，让温斯顿最终成功的被洗脑，成为了为党而生的人，他可以控制自己爱老大哥，也可以恨老大哥，在释放后的心理博弈让他明白，党需要他有什么样的思想，甚至在最后被枪毙的那一刻，自我麻醉的他最终竟然相信他热爱着老大哥，这种从一开始相信客观事实存在到最后变成如此离谱的唯心论的转变，接受“双重思想”的情况，让我比较吃惊，其实现实中也有这般的例子，也就是“PUA”，通过话术，来不断贬低你自己，最终完全受到别人的摆布。</p><p>​      其实书中有很多我不能理解的东西，甚至最后为什么温斯顿会热爱老大哥这个命题，我也是看的别人的书评，听了别人的理解，但是整本书也让我明白了一些道理，比如说PUA，独裁控制，甚至是歪曲历史制造一个虚假的世界，这一切都是这篇小说能传达给我的一些东西，或许以后我还会在看一遍它。</p>]]></content>
      
      
      <categories>
          
          <category> 书库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《1984》 </tag>
            
            <tag> 读后感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有趣的算法问题</title>
      <link href="/archives/90746f6.html"/>
      <url>/archives/90746f6.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    旧坑没填完又开新坑，果然我的学习记录完全是各种偶然发现而拼凑出来的东西，😂。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><p>编写一个程序求1000以内的全部素数。</p><pre class=" language-lang-java"><code class="language-lang-java">for(int i = 2; i <= 1000; i++) {    int sum = 0;    for(int j = 1; j < i; j++) {        if(i % j == 0) {            sum += i;        }    }    if(sum == i) {        System.out.println(i);    }}</code></pre><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><p>编写一个程序求1000以内的所有完数。</p><pre><code>for(int i = 2; i &lt;= 1000; i++) {    int sum = 0;    for(int j = 1; j &lt; i; j++) {        if(i % j == 0) {            sum += j;        }    }    if(sum == i) {        System.out.println(i);    }}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个发现是我在做课程作业的时候发现的，本来并没注意看，因为要做的是<em>题目二</em>，但是看了输出之后我发现，哎，这题的答案和<em>题目一</em>一致让我感到有点意思，排查错误后发现，只需要改动一句话也就是<code>sum += i;</code>比较有意思，自己其实也有好久没有更新自己的博文了，今天就简单更新一下这个好玩的东西，虽然看似并没有那么复杂，但是发现这个问题的一瞬间我还是感到十分的快乐，所以写了这个博文。</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 有趣的算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这个世界太大，脑袋装不下！</title>
      <link href="/archives/49593e3d.html"/>
      <url>/archives/49593e3d.html</url>
      
        <content type="html"><![CDATA[<h1 id="世界真的很大"><a href="#世界真的很大" class="headerlink" title="世界真的很大"></a>世界真的很大</h1><p>​    从历史追溯到现代，以中国的历史就有整整5000年之多，这个5000年人类从使用工具开始，不断学习，到今天的互联网世界，突然发现这个世界真的太大了，大的无妨想象，每天我们涉及的知识量可能是以前古人的几倍甚至几十倍，互联网上的新闻，视频，娱乐，综艺以及音乐，教程等等一系列的东西，可能在我写下这篇文章的一瞬间就会喷涌出一堆的内容，这些内容真的太多了，如果让我去看就仅仅我刚刚写下之前的那一段时间的内容，可能我花费几年的时间都没有办法浏览完，因此无形中我们会发现这个世界真的太大了，大的我无法想象，大的我感到惊慌失措，这片庞大的互联网大世界上那么多的资源就如同小世界一般，而我就如同渺小大陆中的一个小人在这个如此庞大的大陆上寻找，即使我好似拥有者瞬间移动到某个小时的能力，但是我想要欣赏这样的小世界或是评判这个小世界的好坏都需要我花费时间和经历，并且网络上还有类似于那种“小世界测评师”，他们评判了各种不同的小世界，最后将各种小世界又在这互联网大世界中写成了一个个微型小世界相关的内容，看到这些前辈们总结的微型小世界，让我们感到高兴的同时也让我们更加的迷失。</p><h1 id="你欣赏的来吗？"><a href="#你欣赏的来吗？" class="headerlink" title="你欣赏的来吗？"></a>你欣赏的来吗？</h1><p>​    前辈们太过厉害，他们通过自己的摸索写下了一个个微型小世界，并且对每个小世界还进行的特别的说明，比如缺点在哪，优点在哪，这无疑给了我们这些后辈很多的方便，甚至有些前辈们利用自己的能力构建了更加精细的微型小世界体系，这些体系和那些简单构建的体系又有些不同，他们需要利用我们的资源来进行换取，毕竟很多是各种前辈的经验之谈，有些更是独门秘籍，因此前辈们索要一些资源也并没有什么问题，但是对于我们这些后辈其实却带来了很多很多的问题，比如每个领域就有各种不同的前辈对各种小世界的评价，通过前辈们缩略的小世界介绍，让我们在不欣赏全景的情况下，对各个小世界都有了简单的了解，但是这种情况下的欣赏只是简简单单，因此在这种情况下，我们开始了自己的征程，将前辈们所描写的微型小世界各种对比，比拼形成自己想要的小世界体系，但是毕竟是缩放过的微型小世界，当我们尝试使用那些小世界的时候，又开始各种折腾，各种麻烦，以至于到最后，自己想要达成的小世界没制作完成，倒是让自己迷失在了一个个前辈们构建的微型小世界中，无法自拔的沉沦下去，更有胜者相信只要我用资源兑换了前辈们的微型小世界，不需要欣赏就能完全掌握这个微型小世界，那么到头来终究是一场本末倒置的游戏罢了，你浪费了时间，前辈获得了资源，辛苦了前辈们的劳动，而你却迷失在各种前辈的微型小世界的门槛之中。</p><h1 id="如何破除这种怪圈"><a href="#如何破除这种怪圈" class="headerlink" title="如何破除这种怪圈"></a>如何破除这种怪圈</h1><p>​    其实说到底，还是因为这个世界现在沟通太方便了，资源太多了，我如果想要学习一门技术，我可以找到各种我想要的资源，但是看到一半，我们会被其他的资源迷惑，之后陷入各种收集资源，各种学习半吊子的怪圈中，没有自己沉浸式的投入也不会出现强有力的回报，多线程是存在的，但是对于很多人多线程不适合使用，因为在这种情况下同领域下的多线程其实会增加我们自己的负担，一个领域内的内容如果不掌握完整就去进行这个领域的其他内容对于我们自己只会造成无形中的压力，并且会更加的迷茫，当你自己构建一个体系之后再去利用其他的资源进行更加细节化的提升，这才是最好的方式，而不是还没有完全搭建好一个体系的情况下，仅仅因为一点点的困难就去构建别的体系，然后让自己不断的迷茫，很多时候我们浪费的时间就是在收集资源之上而不是在学习之上，这种本末倒置的问题伴随了我很久很久，包括现在的我也有着这样的问题，如何破除，最好的办法就是一个领域中的东西，一个一个学，而不是多个同时学习给自己带来很多不必要的麻烦。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反思 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置相关的小技巧问题集合</title>
      <link href="/archives/11963935.html"/>
      <url>/archives/11963935.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-GitBash控制台出现乱码以及cmd乱码解决方案"><a href="#1-GitBash控制台出现乱码以及cmd乱码解决方案" class="headerlink" title="1.GitBash控制台出现乱码以及cmd乱码解决方案"></a>1.GitBash控制台出现乱码以及cmd乱码解决方案</h1><p><img src="https://s1.ax1x.com/2020/07/23/UL7PDe.png" alt="UL7PDe.png" style="zoom:50%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置问题 </tag>
            
            <tag> 小技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何实现一个简单的单向链表</title>
      <link href="/archives/135c306.html"/>
      <url>/archives/135c306.html</url>
      
        <content type="html"><![CDATA[<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>这里主要是为了实现一个单向链表，那么首先我们得分析一个链表是如何形成的，以及其作用。</p><p>链表的形成可以比喻成当年的火烧赤壁当中曹操利用铁索链接船只，也可以类比现代航行的船队，从图片上我们可以明显观察到一个拖船后面跟着很多的货船，这里拖船就是<strong>头节点</strong>，而最后一个船呢就可以称为<strong>尾结点</strong>。</p><p><img src="https://s1.ax1x.com/2020/07/23/ULwY5R.jpg" alt="ULwY5R.jpg" style="zoom:50%;" /></p><p>那么链表在计算机中的作用又是什么呢？</p><p>这里的了解我并不多，主要的作用肯定是更加方便的插入与删除相关的节点元素，让存储更加便利化，而应用场景可能需要后续补充了。</p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针的定义就不叙述了，这里需要使用指针的目的主要是链接下一个节点地址，指向当前节点的地址。</p><p>那么如何定义一个指针，以及指针该如何使用呢？</p><pre class=" language-lang-c"><code class="language-lang-c">#include <stdio.h>int main(){    //这种是定义一个整型变量    int a = 10;    //这种就是定义一个整型变量的指针    int *p;    //需要注意的是 指针指向的是一个地址，而不是值    //在这里我们已经给a取了一个值10   //那么怎样才能让指针取到这个值？    p = &a;    // &这个符号用来取得a这个变量的地址，然后将其存入p中，这时候的p就指向了a的地址    //*的作用一共有三个分别是    /*        1. 乘号          2. 申明指针        3. 取得指针中的数据    */    //这里使用*号就是为了取得指针中指向地址的数据    printf("%d", *p);    return 0;}</code></pre><h2 id="动态存储函数-malloc"><a href="#动态存储函数-malloc" class="headerlink" title="动态存储函数$ malloc() $"></a>动态存储函数$ malloc() $</h2><p>在<strong>头文件</strong>$ <stdlib.h> $中我们可以使用一个函数$ malloc() $，这个函数的主要作用是<strong>分配字节</strong>，有了这个函数，假使我们要分配一个整型数据的字节那么我们可以直接使用  <code>malloc(4)</code> 来分配字节，可能你会觉得这个并没啥用处，但是如果<strong>你不知道某个类型的字节</strong>，那么加上$ sizeof() $函数，你就可以轻松的为你的指针分配相对应的字节，这样的情况下你可以直接使用 <code>*</code><strong>间接运算符</strong> 来直接进行赋值，这里简单举个例子。</p><pre class=" language-lang-c"><code class="language-lang-c">#include <stdio.h>#include <stdlib.h>int main(){    //定义一个整型的p指针    int *p;    //为指针动态申请一个int类型的空间    p = (int *)malloc(sizeof(int));    //向指针中所指向的内存空间中存入10    *p = 10;    //输出指针p所指向的内存中的值    printf("%d", *p);    return 0;}</code></pre><p>$malloc()$的优势：</p><p>这里我并不能理解，可能不太明白，因此摘抄《啊哈！算法》中对于这个的解释：</p><p>为什么要用这么复杂的办法来存储数据呢？因为之前的方法，我们必须预先准确地知道所需变量的个数，也就是说我们必须定义出所有的变量。比如我们定义了100 个整型变量，那么程序就只能存储100 个整数，如果现在的实际情况是需要存储101个，那必须修改程序才可以。如果有一天你写的软件已经发布或者交付使用，却发现要存储1000 个数才行，那就不得不再次修改程序，重新编译程序，发布一个新版本来代替原来的。而有了$ malloc()$函数我们便可以在程序运行的过程中根据实际情况来申请空间。</p><p><strong>注</strong>：$ malloc() $函数的返回值其实是 <code>void*</code>也就是说其可以强制转换成<strong>任何类型</strong>的指针，只要同指向的指针的<strong>类型</strong>对应即可。</p><h2 id="链表节点的构造"><a href="#链表节点的构造" class="headerlink" title="链表节点的构造"></a>链表节点的构造</h2><p>链表节点主要有<strong>两个</strong>部分组成，其一是<strong>数据</strong>，其二是<strong>后继指针</strong>，当然这里我们只是考虑<strong>单向链表</strong>的情况，那么根据这两个要求我们实现的结构体如下:</p><pre class=" language-lang-c"><code class="language-lang-c">struct node{    //用于存放整型数据    int data;    //后继指针用于指向与其相接的节点    //节点的类型也是 struct node 那么指针就是struct node *    struct node *next;}</code></pre><h2 id="头结点与尾结点的处理"><a href="#头结点与尾结点的处理" class="headerlink" title="头结点与尾结点的处理"></a>头结点与尾结点的处理</h2><p><strong>头结点</strong>由于其自身的原因，所以要单独先建立一个<strong>头结点的指针</strong>用于指向构建的节点；而<strong>尾结点</strong>的处理其实只需要其为NULL就可以了，因此通过这个逻辑我们可以构建好一个链表。</p><pre class=" language-lang-c"><code class="language-lang-c">//这里建立一个头结点的指针struct node* head;//起初并没有指向头结点的值head = NULL;//创建一个临时节点指针struct node *p;//动态申请一个空间，用来存放一个节点，并用临时指针指向这个空间p = (struct node*)malloc(sizeof(struct node));//创建一个当前节点指针struct node *q;//这里假设一个数据int a = 10;//-> 用于访问结构体内部成员 这里是将数据存储到节点的data域中p->data = a;//设置后继节点执行空，也就是当前节点的下一个节点为空p->next = NULL;//这里如果头结点是空那么头结点指向p，如果不是空那么当且节点的后继节点指向临时节点if(head == NULL)    head = p;else    q->next = p;//当前的节点变成现在的临时节点q=p;</code></pre><h1 id="实现一个完整的单向链表"><a href="#实现一个完整的单向链表" class="headerlink" title="实现一个完整的单向链表"></a>实现一个完整的单向链表</h1><p>通过上面的操作，我们就可以明白如何创建一个完整的单向链表，那么下面就是单向链表的完整代码</p><pre class=" language-lang-c"><code class="language-lang-c">#include <stdio.h>#include <stdlib.h>//创建节点的结构体struct node {    //数据域    int data;    //后继指针    struct node *next;}int main(){    //创建一个头节点    struct node *head;    //头结点先定义为NULL    head = NULL;    //创建一个临时节点指针    struct node *p;    //创建一个当前节点指针(这个指针赋值前是临时节点的前一个指针)    struct node *q;    //创建一个节点用来输出节点值    struct node *t;    //用来存放需要创建的节点个数    int n;    //用来临时存放数据域要储存的值    int a;    printf("请输入您需要创建的节点个数\n");    scanf("%d", n);    for(int i = 0 ; i < n ; i++){        //给临时节点指针分配一个节点字节的空间        p = (struct node*)malloc(struct node);        //输入要存储的值        scanf("%d", &a);        //将值存入临时节点的数据域中        p->data = a;        //临时节点的后继指针指向空 这个主要是为了尾结点考虑        p->next = NULL;        //如果头结点是空那么临时节点指向头结点        if(head == NULL)            head = p;           //否则当前节点的后继指针指向临时节点        else            q->next = p;        //当前节点更新为现在的临时节点        q = p;    }    //t节点指向现在的头节点    t = head;    while(t != NULL){        //输出当前的数据域中的值        printf("%d", t->data);        //将t重新指向当前节点的后继节点          t = t->next;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习记录-4</title>
      <link href="/archives/d12c0fb7.html"/>
      <url>/archives/d12c0fb7.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>了解数组的构成之后，紧接着今天学习的就是有关链表相关的内容，链表作为一个基础的数据结构，有着十分重要的使用场景，因此一般都是用来作为开头菜进行相关的内容学习。</p><h1 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h1><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p><strong>定义</strong>：缓存是一种提高<strong>数据读取性能</strong>的一种技术。</p><h3 id="缓存的淘汰策略"><a href="#缓存的淘汰策略" class="headerlink" title="缓存的淘汰策略"></a>缓存的淘汰策略</h3><ol><li>先进先出策略 FIFO(First In, First Out)：先进去的先出来</li><li>最少使用策略 LFU(Least Frequently Used)：使用最少的淘汰</li><li>最近最少使用策略 LRU(Least Recently Used)：最近使用最少的淘汰</li></ol><h2 id="数组与链表的比较"><a href="#数组与链表的比较" class="headerlink" title="数组与链表的比较"></a>数组与链表的比较</h2><h3 id="底层存储结构方面"><a href="#底层存储结构方面" class="headerlink" title="底层存储结构方面"></a>底层存储结构方面</h3><p><strong>数组</strong>需要<strong>连续的内存空间</strong>，<strong>链表</strong>通过<strong>指针</strong>将<strong>零散的内存块</strong>串起来使用。</p><p><img src="https://s1.ax1x.com/2020/07/22/UHtTgJ.jpg" alt="UHtTgJ.jpg" style="zoom:50%;" /></p><h3 id="查找、插入与删除"><a href="#查找、插入与删除" class="headerlink" title="查找、插入与删除"></a>查找、插入与删除</h3><div class="table-container"><table><thead><tr><th></th><th>查找</th><th>插入</th><th>删除</th><th>内存</th></tr></thead><tbody><tr><td>数组</td><td>$ O(1) $</td><td>$ O(n) $</td><td>$ O(n) $</td><td>大小固定</td></tr><tr><td>链表</td><td>$ O(n) $</td><td>$ O(1) $</td><td>$ O(1) $</td><td>动态扩容</td></tr></tbody></table></div><h2 id="链表的基本结构"><a href="#链表的基本结构" class="headerlink" title="链表的基本结构"></a>链表的基本结构</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>每块零散的<strong>内存块</strong>称为<strong>结点</strong>，每个<strong>结点</strong>由<strong>数据</strong>和<strong>后继指针</strong>组成；<strong>第一个</strong>结点叫做<strong>头结点</strong>，<strong>最后一个</strong>结点叫做<strong>尾结点</strong>；<strong>头结点</strong>记录链表的<strong>基地址</strong>，<strong>尾结点</strong>的指针指向<strong>空地址NULL</strong>。</p><p><img src="https://s1.ax1x.com/2020/07/22/UHtLHx.jpg" alt="UHtLHx.jpg" style="zoom:50%;" /></p><h4 id="链表的查找、插入与删除"><a href="#链表的查找、插入与删除" class="headerlink" title="链表的查找、插入与删除"></a>链表的查找、插入与删除</h4><p><strong>链表</strong>的<strong>随机访问</strong>由于是<strong>不连续空间</strong>所以<strong>时间复杂度</strong>为$ O(n) $,<strong>插入</strong>与<strong>删除</strong>的<strong>时间复杂度</strong>都是$ O(1) $,因为只需要<strong>修改</strong>指针指向的<strong>地址</strong>即可。</p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p><strong>循环链表</strong>是一种<strong>特殊</strong>的<strong>单链表</strong>，区别在于<strong>尾结点</strong>，其<strong>尾结点</strong>指向<strong>头结点</strong>，<strong>首尾</strong>相连形成了<strong>循环链表</strong>。</p><p><img src="https://s1.ax1x.com/2020/07/22/UHU8OA.jpg" alt="UHU8OA.jpg" style="zoom:50%;" /></p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p><strong>单向链表</strong>只有<strong>一个</strong>方向，<strong>结点</strong>只有一个<strong>后继指针</strong>指向后面的<strong>结点</strong>；<strong>双向链表</strong>支持<strong>两个</strong>方向，每个<strong>结点</strong>具有一个<strong>后继指针</strong>以及一个<strong>前驱指针</strong>。</p><p><img src="https://s1.ax1x.com/2020/07/22/UHawAx.jpg" alt="UHawAx.jpg" style="zoom:50%;" /></p><h3 id="单向链表与双向链表的比较"><a href="#单向链表与双向链表的比较" class="headerlink" title="单向链表与双向链表的比较"></a>单向链表与双向链表的比较</h3><div class="table-container"><table><thead><tr><th></th><th>存储空间</th><th>删除结点中“值等于某个给定值”的结点</th><th>删除(插入)给定指针指向它的结点</th><th>有序链表</th></tr></thead><tbody><tr><td>单向链表</td><td>数据+后继指针</td><td>查找 $O(n)$   删除$O(1)$</td><td>查找$O(n)$  删除$ O(1) $</td><td>查找$ O(n) $</td></tr><tr><td>双向链表</td><td>数据+前驱指针+后继指针</td><td>查找 $O(n)$   删除$O(1)$</td><td>查找$ O(1) $ 删除$ O(1) $</td><td>查找$ O(logn) $</td></tr></tbody></table></div><h4 id="空间换时间"><a href="#空间换时间" class="headerlink" title="空间换时间"></a>空间换时间</h4><p>内存空间<strong>充足</strong>，追求代码的<strong>执行速度</strong>，可以选择<strong>空间复杂度</strong>较<strong>高</strong>，<strong>时间复杂度</strong>较<strong>低</strong>的算法或者数据结构；反之，内存<strong>紧缺</strong>，选择<strong>时间复杂度</strong>较<strong>高</strong>，<strong>空间复杂度</strong>较<strong>低</strong>的算法或者数据结构。</p><p>对于<strong>执行较慢</strong>的程序，可以通过消耗<strong>更多</strong>的内存（空间换时间）来进行优化；而<strong>消耗过多</strong>内存的程序，可以通过消耗<strong>更多</strong>的时间（时间换空间）来降低内存的消耗。</p><h4 id="时间换空间，空间换时间的例子"><a href="#时间换空间，空间换时间的例子" class="headerlink" title="时间换空间，空间换时间的例子"></a>时间换空间，空间换时间的例子</h4><p>以后补充</p><h3 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h3><p><strong>双向循环链表</strong>指的是<strong>首结点</strong>的<strong>前驱指针</strong>指向<strong>尾结点</strong>的<strong>数据</strong>，<strong>尾结点</strong>的<strong>后继指针</strong>指向<strong>首结点</strong>的<strong>数据</strong>。</p><p><img src="https://s1.ax1x.com/2020/07/22/UHBuxU.jpg" alt="UHBuxU.jpg" style="zoom:50%;" /></p><h2 id="LRU缓存淘汰算法的实现"><a href="#LRU缓存淘汰算法的实现" class="headerlink" title="LRU缓存淘汰算法的实现"></a>LRU缓存淘汰算法的实现</h2><p>我们维护一个<strong>有序单链表</strong>，越靠近链表<strong>尾部</strong>的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始<strong>顺序遍历</strong>链表。</p><ol><li>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从<strong>原来</strong>的位置<strong>删除</strong>，然后再<strong>插入</strong>到链表的<strong>头部</strong>。</li><li>如果此数据没有在缓存链表中，又可以分为两种情况：<ol><li>如果此时缓存<strong>未满</strong>，则将此结点<strong>直接插入</strong>到链表的<strong>头部</strong>；</li><li>如果此时缓存<strong>已满</strong>，则链表<strong>尾结点删除</strong>，将新的数据结点插入链表的<strong>头部</strong>。</li></ol></li></ol><h3 id="如何通过数组实现LRU缓存淘汰策略"><a href="#如何通过数组实现LRU缓存淘汰策略" class="headerlink" title="如何通过数组实现LRU缓存淘汰策略"></a>如何通过数组实现LRU缓存淘汰策略</h3><h4 id="参照链表方法"><a href="#参照链表方法" class="headerlink" title="参照链表方法"></a>参照链表方法</h4><p>我们维护一个<strong>有序的数组</strong>，越靠近数组<strong>尾部</strong>的是越早之前访问的。当有一个新的数据被访问时，我们从数组头开始<strong>遍历寻找</strong>数组。</p><ol><li>如果此数据之前已经被缓存在数组中了，我们遍历得到这个数据对应的下标，将这个下标的数据临时存放一个变量中，并将从其下标位置之前的数据统统向后一位，然后将临时存放在变量中的数据写入头部。</li><li>如果此数据没有在缓存数组中，分为两种情况：<ol><li>如果此时数组未满，则将所有数据向后移动一位，将数据直接插入到头部</li><li>如果此时数组已满，则同样将所有数据向后移动一位，将数据插入到头部</li></ol></li></ol><h4 id="不参照链表"><a href="#不参照链表" class="headerlink" title="不参照链表"></a>不参照链表</h4><p>我们维护一个有序数组，越靠近数组头部的是越早之前访问的。当有一个新的数据被访问是，我们从数组头开始便利寻找数组。</p><ol><li>如果此数组之前已经被缓存在数组中了，我们遍历得到这个数据对应的下表，将这个下标的数据临时存放一个变量中，并将从其下标位置往后的数据统统向前一位，让后将临时存放在变量中的数据写入尾部</li><li>如果此数据没有在缓存数组中，分为两种情况<ol><li>如果此时数组未满，则将数据直接写入尾部</li><li>如果次数数组已满，贼将所有数据向前移动一位，将数据插入尾部</li></ol></li></ol><h1 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h1><p>如何判断一个字符串是否是回文字符串的问题，我想你应该听过，我们今天的题目就是基于这个问题的改造版本。如果字符串是通过单链表来存储的，那该如何来判断是一个回文串呢？你有什么好的解决思路呢？相应的时间空间复杂度又是多少呢？</p><p>现有的解决思路：</p><ol><li><p>遍历一遍现有的链表，获得链表的数量，这里分为两种情况</p><ol><li><p>单数的情况</p><p>在此情况下记录中间结点，两两比对，由首结点和中间结点指向的结点开始进行比对即可，当首结点顺序指向到中间结点时比对结束</p></li><li><p>偶数的情况</p><p>在此情况下取中间结点后一个结点，两两比对，由首结点和中间结点后一个结点指向的结点开始进行比对，当首结点顺序指向到中间结点时比对结束，此时将中间结点与中间结点的后一个结点再次比对即可。</p></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法之美 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习记录-3</title>
      <link href="/archives/94f519fc.html"/>
      <url>/archives/94f519fc.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前两天的学习主要学习了算法的介绍以及算法的时间和空间复杂度分析的问题，并且学习了最好，最坏，平均，均摊时间复杂度，今天的学习从数组开始。</p><h1 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h1><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>首先我们要带着一个问题来学习<strong>为什么数组要从<em>0</em>开始编号，而不是从<em>1</em>开始进行编号？</strong></p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>a表示<strong>首地址</strong>，那么a[0],这里0其实准确是<strong>偏移量(offset)</strong>,那么a[k]其实表示的就是偏移<strong>k</strong>个<strong>type_size</strong>的位置，那么a[k]计算公式为：</p><pre class=" language-lang-c"><code class="language-lang-c">a[k]_address  = base_address + k * type_size</code></pre><p>如果从<strong>1</strong>开始，那么计算a[k]的公式为：</p><pre class=" language-lang-c"><code class="language-lang-c">a[k]_address = base_address + (k-1) * type_size</code></pre><p>这里的话多了一次减法操作，其实<strong>最主要</strong>原因可能是<strong>历史原因</strong>。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h3><p><strong>数组（Array）</strong>是一种<strong>线性表</strong>数据结构。它用一组<strong>连续的内存</strong>空间，来存储一组具有<strong>相同类型</strong>的数据。</p><h3 id="数组的三要素"><a href="#数组的三要素" class="headerlink" title="数组的三要素"></a>数组的三要素</h3><h4 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h4><p><strong>线性表</strong>是排成像<strong>一条线</strong>一样的结构，<strong>只</strong>有<strong>前后</strong>关系，同样的线性表结构也有<strong>链表</strong>，<strong>队列</strong>，<strong>栈</strong>。</p><p><strong>非线性表</strong>，并不是简单的<strong>前后</strong>关系。</p><h4 id="连续内存空间"><a href="#连续内存空间" class="headerlink" title="连续内存空间"></a>连续内存空间</h4><p><strong>数组</strong>由需要给与它一段<strong>连续</strong>的空间存储内容，计算机给其分配时是的内存是<strong>连续的</strong>，因此这里会出现一个<strong>弊端</strong>就是如果没有<strong>写满</strong>，那么会造成<strong>内存</strong>的<strong>浪费</strong>。</p><h4 id="相同类型的数据"><a href="#相同类型的数据" class="headerlink" title="相同类型的数据"></a>相同类型的数据</h4><p>作为<strong>数组</strong>，在构造时它存放的<strong>数据类型</strong>是相同的，如果不同会出现报错。</p><h4 id="随机访问特性"><a href="#随机访问特性" class="headerlink" title="随机访问特性"></a>随机访问特性</h4><p>由于<strong>连续内存空间</strong>和<strong>相同类型的数据</strong>的限制，让其出现了<strong>操作低效率</strong>的问题，但是同样也让其能够实现<strong>随机访问</strong>，算是有利有弊。</p><h4 id="如何实现利用下标随机访问数组元素"><a href="#如何实现利用下标随机访问数组元素" class="headerlink" title="如何实现利用下标随机访问数组元素"></a>如何实现利用下标随机访问数组元素</h4><p>首先分配一个长度<strong>10</strong>的<strong>int</strong>类型的数组 <code>int[] a = new int[10];</code>,那么计算机就会给它分配一块<strong>连续空间</strong>，这里假设为1000-1039，同样假设首地址为<code>base_address = 1000</code>.</p><p>计算机会给每个<strong>内存单元</strong>分配一个地址，计算机通过<strong>地址</strong>访问内存中的<strong>数据</strong>，当计算机需要<strong>随机访问</strong>数组中<strong>某个元素</strong>，需要利用<strong>寻址公式</strong>，计算元素的<strong>内存地址 </strong>。</p><pre class=" language-lang-c"><code class="language-lang-c">// 要寻找下标的内存地址 = 首地址 + 下标 * 元素大小a[i]_address = base_address + i * data_type_size;</code></pre><h4 id="一个“错误“的纠正"><a href="#一个“错误“的纠正" class="headerlink" title="一个“错误“的纠正"></a>一个“错误“的纠正</h4><p><strong>数组</strong>和<strong>链表</strong>的<strong>区别</strong>，<strong>错误</strong>答案经常回答：<strong>链表</strong>适合<strong>插入</strong>、<strong>删除</strong>，时间复杂度为$ O(1) $;<strong>数组</strong>适合<strong>查找</strong>，时间复杂度为$ O(1) $。</p><p>数组适合<strong>查找</strong>，但查找即使排序好的数组，利用<strong>二分查找</strong>，时间复杂度为$ O(logn) $,<strong>正确</strong>的表达是<strong>数组</strong>支持<strong>随机访问</strong>，根据<strong>下标</strong>进行<strong>随机访问</strong>的时间复杂度为$ O(1) $。</p><h3 id="低效的“插入”和“删除”"><a href="#低效的“插入”和“删除”" class="headerlink" title="低效的“插入”和“删除”"></a>低效的“插入”和“删除”</h3><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>假设这里执行插入操作，插入位置为第<strong>k</strong>个位置，那么我们可以得到下面这样的代码：</p><pre class=" language-lang-c"><code class="language-lang-c">// 这里我们假设数组长度为n 实际上并不能这么写 这里假设数组的空间会自动扩充int[] a = a[n]for(int i = k ; i < n - 1 ; i++)  {    a[i+1] = a[i]; }</code></pre><p>通过这个我们可以计算时间复杂度</p><p>首先是<strong>最好时间复杂度</strong>，那么这时候为$ O(1) $,这个情况属于<strong>特殊情况</strong>，比如插入在末尾；接下来是<strong>最坏时间复杂度</strong>，那么这个时候在首尾，可能需要执行$ O(n) $次的操作，因为要将从<strong>0</strong>开始到<strong>n</strong>都往后移位；之后就是平均复杂度，这里出现的情况总共有<strong>n</strong>种，那么可以得到如下的公式：</p><script type="math/tex; mode=display">\frac{1+2+3+\cdots+n}{n} = \frac{\frac{n(n+1)}{2}}{n}=\frac{n(n+1)}{2n}=\frac{n+1}{2}=O(n)</script><h5 id="特例"><a href="#特例" class="headerlink" title="特例"></a>特例</h5><p>除了这种移动的操作，还有一种<strong>骚操作</strong>，那就是直接把<strong>原来位置</strong>的元素移动到<strong>末尾</strong>，然后再插入位置在<strong>k</strong>的元素，这样复杂度就变成了$ O(1) $，但是这是一种<strong>特例</strong>操作，只有特定情况使用。</p><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>删除操作其实同插入一样，如果要删除<strong>k</strong>位置的数据，删除完我们要<strong>搬移</strong>相关的数据，所以这样的话，<strong>最好时间复杂度</strong>为$ O(1) $,<strong>最坏时间复杂度</strong>为$ O(n) $，<strong>平均时间复杂度</strong>为$O(n)$。</p><h5 id="特例-1"><a href="#特例-1" class="headerlink" title="特例"></a>特例</h5><p>这个情况在<strong>连续</strong>删除操作执行时，我们可以<strong>记录</strong>数据<strong>被删除</strong>，当数组存储空间<strong>没有</strong>时，我们在<strong>执行</strong>一次<strong>删除</strong>操作。</p><p>这样的例子是<strong>JVM</strong>的<strong>标记清楚垃圾回收算法</strong></p><h3 id="警惕数据访问越界的问题"><a href="#警惕数据访问越界的问题" class="headerlink" title="警惕数据访问越界的问题"></a>警惕数据访问越界的问题</h3><p>对于<strong>C语言</strong>，数组访问越界并没规定编译器该如何处理，因此这种情况下，容易出现<strong>逻辑错误</strong>，这样很多计算机病毒就可以利用<strong>数组越界</strong>访问<strong>非法地址</strong>来实现攻击；其他语言，有些具有<strong>越界检查</strong>。</p><h3 id="容器是否能代替数组"><a href="#容器是否能代替数组" class="headerlink" title="容器是否能代替数组"></a>容器是否能代替数组</h3><h4 id="容器的优势"><a href="#容器的优势" class="headerlink" title="容器的优势"></a>容器的优势</h4><ol><li>封装了数组操作的细节</li><li>支持动态扩容</li></ol><p><strong>注</strong>：创建容器之前最好事先指定数据大小。</p><h4 id="数组的优势"><a href="#数组的优势" class="headerlink" title="数组的优势"></a>数组的优势</h4><ol><li>容器<strong>无法存储</strong>基本类型，需要<strong>封装</strong>，因此具有<strong>性能消耗</strong>。</li><li>数组操作简单情况下，直接使用数组方便</li><li>多维数组下，数组显示直观</li></ol><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><ol><li><p>前面我基于数组的原理引出 JVM 的标记清除垃圾回收算法的核心理念。我不知道你是否使用 Java 语言，理解 JVM，如果你熟悉，可以在评论区回顾下你理解的标记清除垃圾回收算法。</p><p>这一题以后再答。</p></li><li><p>前面我们讲到一维数组的内存寻址公式，那你可以思考一下，类比一下，二维数组的内存寻址公式是怎样的呢？</p><p>一维数组的计算公式为：</p><pre class=" language-lang-c"><code class="language-lang-c">a[i]_address = base_address + i * data_type_size</code></pre><p>二维数组的计算公式为：</p><pre class=" language-lang-c"><code class="language-lang-c">//注意 这里假设数组为m*n的/*    那么这里 i < m j < n    由于内存是一个线性的结构    那么它的存储也是线性的    如果我要i要取到第二层的，那么    前面就排了第一层n个j，    之后再加上此层的j*/a[i][j]_address = base_address + (i * n + j) * type_size</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法之美 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最近生活的记录</title>
      <link href="/archives/8733180c.html"/>
      <url>/archives/8733180c.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这几天其实又开始有一些怠惰的现象了，学习不怎么上心，昨天吧甚至一度疯狂的操作买iPad,导致自己一整天都沉迷在看各种知乎的帖子无法自拔，买的很多课程也都怎么上心看了，现在依然有这个情况，所以我索性现在写一个相关的总结，总结一下最近的日常，顺便也熟悉一下<strong>Markdown</strong>的一些语法功能。</p><h1 id="开销"><a href="#开销" class="headerlink" title="开销"></a>开销</h1><p>说到这个电子产品，这段时间我是深受其害，自从考完试成绩出来的那一刻，我就抑制不住自己了，开始疯狂的花钱，成绩肯定是很理想考了<strong>337</strong>分，但是就是这个分数让我这段时间有点飘，飘飘然的自己花了很多很多的钱，所以这里我想列个表格算一下自己总共花了多少钱。</p><p><img src="https://s1.ax1x.com/2020/07/14/UUZf2V.png" alt="UUZf2V.png"></p><h2 id="电子产品"><a href="#电子产品" class="headerlink" title="电子产品"></a>电子产品</h2><p>这里我准备分类，包括后面可能要花的钱我都准备一一列出，来说说我这段时间的实际花费，这种报复性的消费的确以后得注意，所以这里必须列清楚，列明白。</p><h3 id="手机与其配件"><a href="#手机与其配件" class="headerlink" title="手机与其配件"></a>手机与其配件</h3><p>考完试没过半个月吧，我就换了一台手机又一次成为了“果粉”，实在是苹果的手机太香了，香的我有点上头，想买华为又苦于自己没有那么多钱，所以就入了苹果的iPhone SE 2020,同时买了个AirPods Pro,最近听说IOS 14 对 AirPods Pro要有新功能，所以也是很期待，但是这里还是得列清楚，列明白。</p><h4 id="手机与耳机以及其售后服务"><a href="#手机与耳机以及其售后服务" class="headerlink" title="手机与耳机以及其售后服务"></a>手机与耳机以及其售后服务</h4><div class="table-container"><table><thead><tr><th style="text-align:left">序列</th><th style="text-align:center">产品名称</th><th style="text-align:right">金额花费</th><th style="text-align:right">购买地址</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:center">iPhone SE 2020 128GB + 换休无忧服务</td><td style="text-align:right">3644.94</td><td style="text-align:right">京东自营店</td></tr><tr><td style="text-align:left">2</td><td style="text-align:center">AirPods Pro主动降噪无线蓝牙耳机</td><td style="text-align:right">1799</td><td style="text-align:right">京东自营店</td></tr><tr><td style="text-align:left">3</td><td style="text-align:center">耳机5年全保修服务</td><td style="text-align:right">189</td><td style="text-align:right">京东自营店</td></tr><tr><td style="text-align:left">4</td><td style="text-align:center">耳机3年全保换新服务</td><td style="text-align:right">169</td><td style="text-align:right">京东自营店</td></tr><tr><td style="text-align:left">5</td><td style="text-align:center">苹果鉴定查询服务</td><td style="text-align:right">6</td><td style="text-align:right"></td></tr><tr><td style="text-align:left">6</td><td style="text-align:center">右耳机丢失 购买一只</td><td style="text-align:right">578</td><td style="text-align:right">鸿运展数码店</td></tr><tr><td style="text-align:left"></td><td style="text-align:center">总计</td><td style="text-align:right">6385.94</td></tr></tbody></table></div><p>这里的花费就已经有<strong>5801.94</strong>元，将近<strong>6000</strong>元，之前好像没仔细算，但是这么算一下，这里花费真的很多了。</p><h4 id="手机与耳机配件"><a href="#手机与耳机配件" class="headerlink" title="手机与耳机配件"></a>手机与耳机配件</h4><p>买了手机怎么可能收手，后面我还买了配件，当然很多配件的钱不是我自己付的，但是有一部分也是我自己付的，所以这里也要统计一下，况且好友代付貌似都没有记录，这个账也不好算呐，这里的金额总计是<strong>562.49</strong>元。</p><div class="table-container"><table><thead><tr><th>序列</th><th style="text-align:center">产品名称</th><th style="text-align:right">金额花费</th><th style="text-align:right">购买地址</th></tr></thead><tbody><tr><td>1</td><td style="text-align:center">紫米18W充电头</td><td style="text-align:right">34.90</td><td style="text-align:right">京东自营店</td></tr><tr><td>2</td><td style="text-align:center">华为无线充电27w原装</td><td style="text-align:right">159-10(优惠)=149</td><td style="text-align:right">京东自营店</td></tr><tr><td>3</td><td style="text-align:center">京东京造充电宝 30000毫安</td><td style="text-align:right">94</td><td style="text-align:right">京东自营店</td></tr><tr><td>4</td><td style="text-align:center">紫米充电套装</td><td style="text-align:right">68.90</td><td style="text-align:right">京东自营店</td></tr><tr><td>5</td><td style="text-align:center">开美智海绵耳塞</td><td style="text-align:right">17</td><td style="text-align:right">京东直营店</td></tr><tr><td>6</td><td style="text-align:center">耳机防尘贴</td><td style="text-align:right">10.20</td><td style="text-align:right">京东 帆睿数码店</td></tr><tr><td>7</td><td style="text-align:center">耳帽耳套</td><td style="text-align:right">21.69</td><td style="text-align:right">京东 与乐旗舰店</td></tr><tr><td>8</td><td style="text-align:center">紫米快充线</td><td style="text-align:right">69</td><td style="text-align:right">淘宝 zmi旗舰店</td></tr><tr><td>9</td><td style="text-align:center">亿色iPhoneSE钢化膜</td><td style="text-align:right">35</td><td style="text-align:right">淘宝 esr旗舰店</td></tr><tr><td>10</td><td style="text-align:center">AirPods Pro 保护套</td><td style="text-align:right">26.8</td><td style="text-align:right">imoblie迁千牵专卖店</td></tr><tr><td>11</td><td style="text-align:center">iPhone SE 2020 保护壳</td><td style="text-align:right">36</td><td style="text-align:right">广得利旗舰店</td></tr><tr><td></td><td style="text-align:center">总计</td><td style="text-align:right">562.49</td></tr></tbody></table></div><h3 id="iPad与其配件"><a href="#iPad与其配件" class="headerlink" title="iPad与其配件"></a>iPad与其配件</h3><h4 id="iPad预估花费"><a href="#iPad预估花费" class="headerlink" title="iPad预估花费"></a>iPad预估花费</h4><p>因为录取通知书即将要到了，所以后面iPad也有相关的花费这里，就把花费也同时计算一下，毕竟也提前准备了配件，那么这里总计的金额就是<strong>9000</strong>元。</p><div class="table-container"><table><thead><tr><th>序列</th><th style="text-align:center">产品名称</th><th style="text-align:right">金额花费</th><th style="text-align:right">购买地址</th></tr></thead><tbody><tr><td>1</td><td style="text-align:center">12.9英寸 iPad Pro WLAN CL 1T</td><td style="text-align:right">12299</td><td style="text-align:right">无锡恒隆广场自营店</td></tr><tr><td>2</td><td style="text-align:center">AppleCare+ 服务计划(适用于iPad Pro)</td><td style="text-align:right">799</td><td style="text-align:right">无锡恒隆广场自营店</td></tr><tr><td>3</td><td style="text-align:center">AirPods Pro</td><td style="text-align:right">1999</td><td style="text-align:right">无锡恒隆广场自营店</td></tr><tr><td>4</td><td style="text-align:center">Apple Pencil(第二代)</td><td style="text-align:right">895</td><td style="text-align:right">无锡恒隆广场自营店</td></tr><tr><td>5</td><td style="text-align:center">优惠</td><td style="text-align:right">-1246</td><td style="text-align:right">暑假优惠</td></tr><tr><td>6</td><td style="text-align:center">第一次总计花费</td><td style="text-align:right">14746</td><td style="text-align:right"></td></tr><tr><td>7</td><td style="text-align:center">张高付款</td><td style="text-align:right">-1346</td><td style="text-align:right"></td></tr><tr><td>8</td><td style="text-align:center">第二次总计花费</td><td style="text-align:right">13400</td><td style="text-align:right"></td></tr><tr><td>9</td><td style="text-align:center">大爷付款</td><td style="text-align:right">3000</td><td style="text-align:right"></td></tr><tr><td>10</td><td style="text-align:center">第三次总计花费</td><td style="text-align:right">10400</td></tr></tbody></table></div><h4 id="iPad配件"><a href="#iPad配件" class="headerlink" title="iPad配件"></a>iPad配件</h4><p>这里相关的配件也有很多，所以这里也计算下这个花费，总计<strong>432.97</strong>元。</p><div class="table-container"><table><thead><tr><th>序列</th><th style="text-align:center">产品名称</th><th style="text-align:right">金额花费</th><th style="text-align:right">购买地址</th></tr></thead><tbody><tr><td>1</td><td style="text-align:center">Anker USB-C 充电器 PD 30W</td><td style="text-align:right">149</td><td style="text-align:right">京东自营店</td></tr><tr><td>2</td><td style="text-align:center">iPad Pro 2020 保护套 防弯硬背板</td><td style="text-align:right">108</td><td style="text-align:right">锐益数码专营店</td></tr><tr><td>3</td><td style="text-align:center">亿色 2020全屏 iPad Pro 钢化膜</td><td style="text-align:right">76.5</td><td style="text-align:right">esr旗舰店</td></tr><tr><td>4</td><td style="text-align:center">亿色 2020 镜头膜</td><td style="text-align:right">49.5</td><td style="text-align:right">esr旗舰机</td></tr><tr><td>5</td><td style="text-align:center">二代笔 笔套</td><td style="text-align:right">25</td><td style="text-align:right">信诚e家</td></tr><tr><td>6</td><td style="text-align:center">笔尖套</td><td style="text-align:right">8.95</td><td style="text-align:right">海明视数码专营店</td></tr><tr><td>7</td><td style="text-align:center">苹果收纳盒</td><td style="text-align:right">16.02</td><td style="text-align:right">博音旗舰店</td></tr><tr><td>8</td><td style="text-align:center">苹果耳机收纳包</td><td style="text-align:right">35.28</td><td style="text-align:right">东莞数码包在线</td></tr><tr><td>9</td><td style="text-align:center">亿色 AirPods Pro 保护套</td><td style="text-align:right">34.92</td><td style="text-align:right">esr旗舰店</td></tr><tr><td>10</td><td style="text-align:center">AirPods Pro 保护耳套</td><td style="text-align:right">39</td><td style="text-align:right">ahastyle旗舰店</td></tr><tr><td>11</td><td style="text-align:center">OtterBox iPad 防摔保护套</td><td style="text-align:right">707.99</td><td style="text-align:right">OtterBox手机配件旗舰店</td></tr><tr><td></td><td style="text-align:center">总计</td><td style="text-align:right">1250.16</td></tr></tbody></table></div><h3 id="其他花费"><a href="#其他花费" class="headerlink" title="其他花费"></a>其他花费</h3><p>其他花费就是一些杂七杂八的了，还有软件方面的花费了，这里总计高达了<strong>1290</strong>元，其中<strong>699</strong>元的<strong>研磨院自习室</strong>算是很大的浪费了！！！</p><div class="table-container"><table><thead><tr><th>序列</th><th style="text-align:center">产品名称</th><th style="text-align:right">金额花费</th><th style="text-align:right">购买地址</th></tr></thead><tbody><tr><td>1</td><td style="text-align:center">瑞士军刀 大容量 旅行书包</td><td style="text-align:right">146</td><td style="text-align:right">svvisssvver箱包旗舰店</td></tr><tr><td>2</td><td style="text-align:center">密码软件</td><td style="text-align:right">6</td><td style="text-align:right">Apple</td></tr><tr><td>3</td><td style="text-align:center">Notability</td><td style="text-align:right">60</td><td style="text-align:right">Apple</td></tr><tr><td>4</td><td style="text-align:center">GoodNotes 5</td><td style="text-align:right">50</td><td style="text-align:right">Apple</td></tr><tr><td>5</td><td style="text-align:center">Alook浏览器</td><td style="text-align:right">6</td><td style="text-align:right">Apple</td></tr><tr><td>6</td><td style="text-align:center">我的小目标</td><td style="text-align:right">68</td><td style="text-align:right">Apple</td></tr><tr><td>7</td><td style="text-align:center">蒙哥英语原版阅读器</td><td style="text-align:right">18</td><td style="text-align:right">Apple</td></tr><tr><td>8</td><td style="text-align:center">IObit Uninstaller 9 Pro</td><td style="text-align:right">69</td><td style="text-align:right">APSGO</td></tr><tr><td>9</td><td style="text-align:center">IObit Smart Defrag 6 Pro</td><td style="text-align:right">69</td><td style="text-align:right">APSGO</td></tr><tr><td>10</td><td style="text-align:center">IObit Advanced SystemCare 13 Pro</td><td style="text-align:right">99</td><td style="text-align:right">APSGO</td></tr><tr><td>11</td><td style="text-align:center">Iris Pro 护眼软件</td><td style="text-align:right">55.10</td><td style="text-align:right">APSGO</td></tr><tr><td>12</td><td style="text-align:center">研磨院自习室</td><td style="text-align:right">699</td><td style="text-align:right">无锡清名桥研磨院</td></tr><tr><td>13</td><td style="text-align:center">三星 970Evo 512GB</td><td style="text-align:right">800</td><td style="text-align:right">五爱广场</td></tr><tr><td>14</td><td style="text-align:center">文本识别转换</td><td style="text-align:right">18</td><td style="text-align:right">Apple</td></tr><tr><td></td><td style="text-align:center">总计</td><td style="text-align:right">2163.1</td></tr></tbody></table></div><h3 id="课程花费"><a href="#课程花费" class="headerlink" title="课程花费"></a>课程花费</h3><p>除了这些我还买了一些相关的学习课程 ，因此这里的课程也要计算一下价格，那么这里总共的花费就是<strong>2942.09</strong>元。</p><div class="table-container"><table><thead><tr><th>序列</th><th style="text-align:center">产品名称</th><th style="text-align:right">金额花费</th><th style="text-align:right">购买地址</th></tr></thead><tbody><tr><td>1</td><td style="text-align:center">SVip考研视频</td><td style="text-align:right">60</td><td style="text-align:right">尖端考研</td></tr><tr><td>2</td><td style="text-align:center">ABOBOO年费</td><td style="text-align:right">299</td><td style="text-align:right">ABOBOO</td></tr><tr><td>3</td><td style="text-align:center">MindMaster全平台终身订阅版</td><td style="text-align:right">680</td><td style="text-align:right">深圳亿图公司</td></tr><tr><td>4</td><td style="text-align:center">Java 全站通</td><td style="text-align:right">453.30</td><td style="text-align:right">How2J</td></tr><tr><td>5</td><td style="text-align:center">Java 练习题答案</td><td style="text-align:right">27.84</td><td style="text-align:right">How2J</td></tr><tr><td>6</td><td style="text-align:center">慕课网课程</td><td style="text-align:right">963.05</td><td style="text-align:right">慕课网</td></tr><tr><td>7</td><td style="text-align:center">数据结构与算法之美</td><td style="text-align:right">29.9</td><td style="text-align:right">极客时间</td></tr><tr><td>8</td><td style="text-align:center">编译原理之美</td><td style="text-align:right">69</td><td style="text-align:right">极客时间</td></tr><tr><td>9</td><td style="text-align:center">资源栈的所有内容</td><td style="text-align:right">360</td><td style="text-align:right">资源栈</td></tr><tr><td>10</td><td style="text-align:center">史汉生网课</td><td style="text-align:right">43.75</td><td style="text-align:right"></td></tr><tr><td></td><td style="text-align:center">总计</td><td style="text-align:right">2985.84</td></tr></tbody></table></div><h1 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h1><p>计算完里的花费我都不想写别的东西了，所以这里最后就计算一下自己的总共花费吧，果然没出我所料那这么算我可能这几个月的花费都要破<strong>25000</strong>元大关了！</p><div class="table-container"><table><thead><tr><th>序列</th><th>产品总计大类</th><th>总计金额</th></tr></thead><tbody><tr><td>1</td><td>手机与耳机以及其售后服务</td><td>6385.94</td></tr><tr><td>2</td><td>手机与耳机配件</td><td>562.49</td></tr><tr><td>3</td><td>iPad预估花费</td><td>10400</td></tr><tr><td>4</td><td>其他花费</td><td>2163.1</td></tr><tr><td>5</td><td>课程花费</td><td>2985.84</td></tr><tr><td>6</td><td>iPad配件</td><td>1250.16</td></tr><tr><td></td><td>总计</td><td>23747.53</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反思 </tag>
            
            <tag> 私密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习记录-2</title>
      <link href="/archives/384faa82.html"/>
      <url>/archives/384faa82.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>昨天学习了主要是简单的概念学习与时间和空间复杂度分析的学习，今天学习的内容是时间与空间复杂度问题的第二部分，这部分主要是关于最好，最坏，平均，均摊时间复杂度相关的内容。</p><h1 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h1><h2 id="最好、最坏、平均情况时间复杂度"><a href="#最好、最坏、平均情况时间复杂度" class="headerlink" title="最好、最坏、平均情况时间复杂度"></a>最好、最坏、平均情况时间复杂度</h2><h3 id="最好、最坏情况时间复杂度"><a href="#最好、最坏情况时间复杂度" class="headerlink" title="最好、最坏情况时间复杂度"></a>最好、最坏情况时间复杂度</h3><p>未优化的版本,不管找没找到都循环都会执行结束</p><pre class=" language-lang-c"><code class="language-lang-c">// n表示数组array的长度//这段代码主要的功能是实现 //查找一个数组里是否有和x相同的元素 //如果相同返回下标 不相同那么-1 int find(int[] array, int n, int x) {    //这里由上面可知道数组长度为n 空间复杂度为O(n)  int i = 0;  //执行1次  int pos = -1; //执行1次  for (; i < n; ++i) { //执行n次    if (array[i] == x)  //执行n次        pos = i; //执行1次  }  //那么可以知道这个的时间复杂度为O(n)  return pos;}</code></pre><p>优化后的版本，找到后就<strong>跳出</strong>，找不到那么执行整个循环，那么就有<strong>多种</strong>情况</p><pre class=" language-lang-c"><code class="language-lang-c">// n表示数组array的长度int find(int[] array, int n, int x) {  int i = 0;  int pos = -1;  for (; i < n; ++i) {    if (array[i] == x) {       pos = i;       break;    }  }  return pos;}</code></pre><p>因为这个原因所以出现了<strong>最好时间复杂度</strong>和<strong>最坏时间复杂度</strong>以及<strong>平均时间复杂度</strong>。</p><p><strong>最好时间复杂度</strong>就是能够<strong>最快速</strong>情况下找到<strong>跳出</strong>循环的情况，根据上面的例子我们可以知道<strong>最好时间复杂度</strong>就是在数组的<strong>第一个元素</strong>。</p><p><strong>最坏时间复杂度</strong>说明了在<strong>最不理想</strong>的情况下<strong>找出</strong>元素，那么根据上面的例子我们可以推测知道<strong>最坏时间复杂度</strong>就是<strong>没有</strong>找到的情况，那么这时候可能要循环整整<strong>n</strong>次。</p><h3 id="平均情况时间复杂度"><a href="#平均情况时间复杂度" class="headerlink" title="平均情况时间复杂度"></a>平均情况时间复杂度</h3><p>这个需要单独拉出来讲，我们从上面知道<strong>最好时间复杂度</strong>为循环执行<strong>一次</strong>，<strong>最坏时间复杂度</strong>为没找到也就是说循环执行<strong>n次</strong>，那么这里总共的情况可能为<strong>数组内$ [0,n-1] $</strong>和<strong>不在数组中</strong>,那么这里总共的情况就是<script type="math/tex">n+1</script>次，那么这里我们把所有元素遍历的情况<strong>累加</strong>除以可能执行的次数，得到：</p><script type="math/tex; mode=display">\frac{1+2+3+\cdots+n+n}{n+1}=\frac{\frac{n(n+1)}{2}+n}{n+1}=\frac{\frac{n^2+n}{2}+\frac{2n}{2}}{n+1}=\frac{\frac{n^2+n+2n}{2}}{n+1}=\frac{n^2+3n}{2(n+1)}=\frac{n(n+3)}{2(n+1)}</script><p>这里补充一下<strong>等差数列</strong>的求和公式为:</p><script type="math/tex; mode=display">S_n=\frac{n*(a_1+a_n)}{2}</script><p>由上面的式子$ \frac{n(n+3)}{2(n+1)} $根据我们之前学习到的<strong>大O表示法</strong>中<strong><span style='color:red'>总复杂度</span></strong>等于<strong><span style='color:red'>量级最大</span></strong>的那段代码的复杂度可以得到下面这个式子:</p><script type="math/tex; mode=display">\frac{n(n+3)}{2(n+1)}=\frac{n^2+3n}{2n+2}=\frac{n^2}{2n}=\frac{n}{2}=n</script><p>这里我们将<strong>系数</strong>，<strong>低阶</strong>，<strong>常量</strong>都省略后得到了<strong>时间复杂度</strong>为$ O(n) $，这个计算结论虽然正确但是没有考虑<strong>概率</strong>。</p><p>这里假设<strong>数组中可能性</strong>和<strong>数组外可能性</strong>都是$ \frac{1}{2} $,那么在数组中位置的<strong>概率</strong>为$ \frac{1}{n} $,也就是说明在数组中的各个位置的可能性为:</p><script type="math/tex; mode=display">\frac{1}{2}*\frac{1}{n}=\frac{1}{2n}</script><p>那么这样我们就可以推出一个公式为：</p><script type="math/tex; mode=display">1*\frac{1}{2n}+2*\frac{1}{2n}+3*\frac{1}{2n}+\cdots+n*\frac{1}{2n}+n*\frac{1}{2}\\=\frac{1+2+3+\cdots+n+n^2}{2n}\\=\frac{\frac{n(n+1)}{2}+n^2}{2n}=\frac{\frac{n(n+1)}{2}+\frac{2n^2}{2}}{2n}\\ =\frac{\frac{n^2+n+2n^2}{2}}{2n}=\frac{3n^2+n}{4n}=\frac{3n+1}{4}</script><p>所以根据这个结果我们可以知道<strong>真正</strong>的值可能是$ \frac{3n+1}{4}  $,这个值在<strong>概率论</strong>中为<strong>加权平均值</strong>(<strong>期望值</strong>)，那么<strong>平均时间复杂度</strong>全称其实叫<strong>加权平均时间复杂度</strong>或者<strong>期望时间复杂度</strong>。</p><h3 id="利用三种复杂度表示法的情况？"><a href="#利用三种复杂度表示法的情况？" class="headerlink" title="利用三种复杂度表示法的情况？"></a>利用三种复杂度表示法的情况？</h3><p><strong>一般情况</strong>，不需要<strong>考虑</strong>三种情况，只有在<strong>时间复杂度</strong>有<strong>量级差距</strong>,才使用<strong>最坏时间复杂度</strong>，<strong>最好时间复杂度</strong>和<strong>平均时间复杂度</strong>的情况来区分问题。</p><h2 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h2><h3 id="均摊时间复杂度与平均复杂度的区分"><a href="#均摊时间复杂度与平均复杂度的区分" class="headerlink" title="均摊时间复杂度与平均复杂度的区分"></a>均摊时间复杂度与平均复杂度的区分</h3><p><strong>平均时间复杂度</strong>只会在某些<strong>特殊情况</strong>使用，而<strong>均摊时间复杂度</strong>可能使用比<strong>平均时间复杂度</strong>更加<strong>特殊</strong>，更加<strong>有限</strong>。</p><pre class=" language-lang-c"><code class="language-lang-c"> // array表示一个长度为n的数组 // 代码中的array.length就等于n int[] array = new int[n]; int count = 0; void insert(int val) {    if (count == array.length) {       int sum = 0;       for (int i = 0; i < array.length; ++i) {          sum = sum + array[i];       }       array[0] = sum;       count = 1;    }    array[count] = val;    ++count; }</code></pre><p><strong>最坏时间复杂度</strong>：插入时数组没有空位，那么这个时候代码最多执行n次，所以<strong>时间复杂度</strong>为$ O(n) $;</p><p><strong>最好时间复杂度</strong>：插入时数组有空位，那么这个时候代码最多执行1次，所以<strong>时间复杂度</strong>为 $ O(1) $ ;</p><p><strong>平均时间复杂度</strong>：分为<strong>有空位</strong>和<strong>没有空位</strong>两种情况，<strong>有空位</strong>总共有<strong>n</strong>种情况，<strong>没有空位</strong>发生总共有<strong>1</strong>种情况，那么总共会发生<strong>n+1</strong>种情况，每种情况的发生<strong>概率</strong>一致为$ \frac{1}{n+1} $，由此我们可以推算如下公式。</p><script type="math/tex; mode=display">1*\frac{1}{n+1}+1*\frac{1}{n+1}+\cdots+1*\frac{1}{n+1}+n*\frac{1}{n+1}\\=\frac{n+n}{n+1}=\frac{2n}{n+1}=O(2)=O(1)</script><p><strong>注</strong>:这里<strong>有空位</strong>的<strong>时间复杂度</strong>都为$ O(1) $,因为执行 <code>array[count] = val;</code></p><p><strong>没有空位</strong>的<strong>时间复杂度</strong>为$ O(n) $,这里执行的是:</p><pre class=" language-lang-C"><code class="language-lang-C">if (count == array.length) { //执行1次       int sum = 0; //执行1次       for (int i = 0; i < array.length; ++i) { //这里数组假设的长度为n 那么这里执行n次          sum = sum + array[i]; //循环块内 执行n次       }       array[0] = sum; //执行1次       count = 1; //执行1次    }/*从这里就可以知道根据之前学习的 三 大 原 则的第一条:1. 只关注循环执行次数 最多 的代码2. 加法法则: 总复杂度 等于 量级最大 的那段代码的复杂度3. 乘法法则: 嵌套代码的复杂度 等于 嵌套 内外 代码复杂度的 乘积我们可以知道这个情况的时间复杂度为O(n)*/</code></pre><h3 id="Insert-代码块与-find-代码块的对比"><a href="#Insert-代码块与-find-代码块的对比" class="headerlink" title="$ Insert() $代码块与$find()$代码块的对比"></a>$ Insert() $代码块与$find()$代码块的对比</h3><div class="table-container"><table><thead><tr><th>$ Insert() $代码</th><th>$ find() $代码</th></tr></thead><tbody><tr><td><code>// array表示一个长度为n的数组</code><br/> <code>// 代码中的array.length就等于n</code><br/> <code>int[] array = new int[n];</code><br/> <code>int count = 0;</code><br/> <br/> <code>void insert(int val) {</code><br/>    <code>if (count == array.length) {</code><br/>     <code>int sum = 0;</code><br/>    <code>for (int i = 0; i &lt; array.length; ++i) {</code><br/>       <code>sum = sum + array[i];</code><br/>    <code>}</code><br/>    <code>array[0] = sum;</code><br/>     <code>count = 1;</code><br/>   <code>}</code><br/><br/><code>array[count] = val;</code><br/>  <code>++count;</code><br/> <code>}</code></td><td><code>// n表示数组array的长度</code><br/>  <code>int find(int[] array, int n, int x) {</code><br/>  <code>int i = 0;</code><br/> <code>int pos = -1;</code><br/>  <code>for (; i &lt; n; ++i) {</code><br/>   <code>if (array[i] == x) {</code><br/>    <code>pos = i;</code><br/>  <code>break;</code><br/>  <code>}</code><br/>  <code>}</code><br/> <code>return pos;</code><br/>  <code>}</code></td></tr></tbody></table></div><h4 id="1-第一个区别"><a href="#1-第一个区别" class="headerlink" title="1. 第一个区别"></a>1. 第一个区别</h4><p>$ Insert() $中<strong>大部分</strong>复杂度为$ O(1) $,只有在<strong>空间不够</strong>时复杂度为$ O(n) $;$ find() $中<strong>极端情况</strong>复杂度为$ O(1) $。</p><h4 id="2-第二个区别"><a href="#2-第二个区别" class="headerlink" title="2. 第二个区别"></a>2. 第二个区别</h4><p>$ Insert() $中$ O(1) $与$ O(n) $出现情况很<strong>规律</strong>，有<strong>时序关系</strong>，比如完成<strong>一个</strong>$O(n)$操作后面接着$ n - 1$个$O(1)$操作，如此循环。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>因此遇到这种代码我们不需要使用<strong>平均时间复杂度</strong>的分析步骤<strong>找出概率</strong>，<strong>计算加权平均值</strong>，而是使用一个新的方法<strong>摊还分析法</strong>，因此这种<strong>时间复杂度</strong>称为<strong>均摊时间复杂度</strong>，这里来说步骤就是<strong>一次</strong>复杂度<strong>不同</strong>的情况，后面跟着<strong>一堆</strong>复杂度<strong>相同</strong>的情况，并且<strong>循环往复</strong>；就比如上面的$ Insert() $函数为<strong>一次</strong>$ O(n) $操作，跟着$ n - 1$次的$ O(1) $操作，如此<strong>循环往复</strong>。</p><p><strong>总的来说</strong>，<strong>均摊时间复杂度</strong>可以称为<span style='color:red;'><strong>特殊</strong></span>的<strong>平均时间复杂度</strong>。</p><h1 id="课后思考题"><a href="#课后思考题" class="headerlink" title="课后思考题"></a>课后思考题</h1><pre class=" language-lang-c"><code class="language-lang-c">// 全局变量，大小为10的数组array，长度len，下标i。int array[] = new int[10]; int len = 10;int i = 0;// 往数组中添加一个元素void add(int element) {   if (i >= len) { // 数组空间不够了     // 重新申请一个2倍大小的数组空间     int new_array[] = new int[len*2];     // 把原来array数组中的数据依次copy到new_array     for (int j = 0; j < len; ++j) {       new_array[j] = array[j];     }     // new_array复制给array，array现在大小就是2倍len了     array = new_array;     len = 2 * len;   }   // 将element放到下标为i的位置，下标i加一   array[i] = element;   ++i;}</code></pre><p><strong>思路</strong></p><p>这里的$ add() $函数一共有两种情况<strong>数组空间够</strong>和<strong>数组空间不够</strong>两种情况：</p><p>首先我们分析<strong>最好时间复杂度</strong>，这个时候属于<strong>数组空间够</strong>的情况，那么这里只需要执行 <code>array[i] = element; //执行1次</code>以及 <code>++i; //执行一次</code>所以这种情况下<strong>时间复杂度</strong>为$ O(1) $；</p><p>其次分析<strong>最坏时间复杂度</strong>，这个时候属于<strong>数据空间不够</strong>的情况，那么这里下面需要执行的就是$ add() $函数的整个代码：</p><pre class=" language-lang-c"><code class="language-lang-c">void add(int element) {   if (i >= len) { // 数组空间不够了 //执行1次     // 重新申请一个2倍大小的数组空间     int new_array[] = new int[len*2];  //执行1次     // 把原来array数组中的数据依次copy到new_array     for (int j = 0; j < len; ++j) { //执行10次 但是 由于不知道这里len可能的情况 所以 假设这里实际可以为n次       new_array[j] = array[j]; //这个执行n次     }     // new_array复制给array，array现在大小就是2倍len了     array = new_array; //执行1次     len = 2 * len;  //执行1次   }   // 将element放到下标为i的位置，下标i加一   array[i] = element; //执行1次   ++i; //执行一次}</code></pre><p>那么这种情况下的<strong>时间复杂度</strong>其实为$O(n)$；</p><p>最后我们计算<strong>平均复杂度</strong>，我们可以从实际出发在<strong>一次</strong>时间复杂度为$ O(n) $的情况后，会出现 $ n - 1 $次时间复杂度为$ O(1) $的情况，因此这里其实需要计算的是<strong>均摊时间复杂度</strong>，这种情况下我们可以分析<strong>数据空间够</strong>有<strong>n*</strong>种可能的情况，<strong>数据空间不够</strong>有<strong>1</strong>种情况，因此这里总共有<strong>n+1</strong>次情况，因此可以推出的公式为：</p><script type="math/tex; mode=display">1*\frac{1}{n+1}+1*\frac{1}{n+1}+\cdots+1*\frac{1}{n+1}+n*\frac{1}{n+1}\\=\frac{n+n}{n+1}=\frac{2n}{n+1}=O(2)=O(1)</script><p>其实这里可以发现和$ Insert() $函数的<strong>均摊复杂度</strong>是一致的，所以这一题其实就是举的一个<strong>特定情况</strong>的<strong>平均时间复杂度</strong>问题。</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法之美 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习记录-1</title>
      <link href="/archives/a146fb38.html"/>
      <url>/archives/a146fb38.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这个文章系列主要用来记录自己学习算法与数据结构的相关记录，期望自己可以每日都写，但是具体的话还是根据实际学习的情况来，主要是用来总结，也算是用来强迫鞭策自己进行知识内容的输出，毕竟学习这些内容是枯燥的，利用各种资源加上自己的总结来让自己更加了解这方面的知识对未来并没有什么坏处。</p><h1 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h1><h2 id="算法与数据结构概念"><a href="#算法与数据结构概念" class="headerlink" title="算法与数据结构概念"></a>算法与数据结构概念</h2><ol><li><strong>算法</strong>表示操作数据的一组方法。</li><li><strong>数据结构</strong>表示一组数据的存储结构。</li><li><strong>狭义上</strong> 两者差不多主要是由前人总结下来的一些实际操作场景中的抽象方法，用来解决实际开发问题。</li><li><strong>两者关系</strong>相辅相成，数据结构为算法<strong>服务</strong>，算法主要作用在特定的数据结构之上。</li></ol><h2 id="大O复杂度表示法"><a href="#大O复杂度表示法" class="headerlink" title="大O复杂度表示法"></a>大O复杂度表示法</h2><h3 id="如何理解大O复杂度表示法"><a href="#如何理解大O复杂度表示法" class="headerlink" title="如何理解大O复杂度表示法"></a>如何理解大O复杂度表示法</h3><p>第一个简单代码分析</p><pre class=" language-lang-c"><code class="language-lang-c"> //这里假设的是每行执行时间为time int cal(int n) {   int sum = 0;  // 这里为 1 * time   int i = 1; // 这里为 2 * time    for (; i <= n; ++i) { // 这里分析主要执行的操作是++i操作 要执行n次 因为 i <= n     //在这个里面的代码块执行是一个循环结构     sum = sum + i; //这里执行的操作是n次   }   //循环结束之后 这里总共执行 2n * time次   // 那么不算最后的输出 在这个内部函数逻辑里面它的总共执行次数为 (2n+2) * time   return sum; }</code></pre><p>这里对 <code>for(;i&lt;=n;i++)</code> 的循环块代码利用另一种<strong>循环结构</strong>的分析</p><pre class=" language-lang-c"><code class="language-lang-c">while(true){    //这里的if判断说明的是当i > n之后跳出这个循环    if(i > n)            break;    //这个操作其实是 i = i + 1; 那么通过上面的条件就知道这个要执行 n 次    else         ++i;    //这个操作是在循环块代码内部那么执行 n 次    sum = sum + i;}// 因此最后这个循环体执行n + n 次的操作 也就是 2n</code></pre><p>第二个部分的代码分析</p><pre class=" language-lang-c"><code class="language-lang-c"> //这里假设的是每行执行时间为time int cal(int n) {   int sum = 0; //这里为 1 * time   int i = 1; //这里为 2 * time   int j = 1; //这里为 3 * time   for (; i <= n; ++i) {  //这里分析主要执行的是++i操作 要执行n次 因为 i <= n     // 这里是循环代码的内部操作     j = 1; //这里执行的操作是n次     for (; j <= n; ++j) { //这里分析主要执行的是++j操作 要执行n次 但是它在循环操作里面 所以就是 n*n次       //这里是循环代码的内部操作       sum = sum +  i * j; //这里执行的操作是n*n次     }     //跳出这个循环后这里总共执行n*n + n*n 也就是 2n^2   }    //跳出这个循环后 这里总共执行 2n + 2n^2    //那么这个函数加在一起总共执行了 (2n^2 + 2n + 3) * time }</code></pre><p>这里同样利用另一种<strong>循环结构</strong>进行分析</p><pre class=" language-lang-c"><code class="language-lang-c">while(true){    if (i > n) //这里主要表示 i > n 的时候 跳出这个循环        break;    else        ++i; // 这里是说如果i <=n 那么执行 i = i + 1;的操作 那么这里总共执行 n 次    j = 1; // 这里 在循环块内部 那么执行 n次    while(true){        if (j > n) // 这里主要表示 j > n 的时候跳出这个循环            break;        else            // 这里是说如果 j <= n 的时候执行 j = j + 1的操作 那么在这个循环体内执行 n次             // 但是外面还有一个循环体  所以这里这个总共执行n * n次            ++j;         // 这说明 在循环体内执行n次 由于是循环体套循环体所以这里总共执行 n * n次        sum = sum + i * j;    }}// 因此最后这个循环体总共执行的操作是 2n^2 + 2n的操作</code></pre><p>从这两个推导我们得到一个规律<strong>所有代码的执行时间T(n)与每行代码的执行次数n成正比</strong>,那么我们可以得到一个公式也就是</p><script type="math/tex; mode=display">T(n) = O(f(n))</script><p>这里$ T(n) $表示的<strong>代码总共执行时间</strong>；$ n $ 表示的是<strong>数据规模的大小</strong>；$ f(n) $表示的是<strong>每行代码执行的次数总和</strong>；公式中的$ O $用来表示<strong>代码执行时间</strong>$ T(n) $与<strong>执行次数</strong>$ f(n) $表达式成正比。</p><p><strong>注意</strong>：<strong>大O</strong>时间复杂度实际并不表示<strong>具体</strong>表示代码<strong>真正</strong>执行时间，而是表示<strong>代码执行时间</strong>随<strong>数据规模</strong>形成的一种<strong>增长变化趋势</strong>，也可以称为<strong>渐进时间复杂度</strong>，简称<strong>时间复杂度</strong>。</p><h3 id="如何分析时间复杂度"><a href="#如何分析时间复杂度" class="headerlink" title="如何分析时间复杂度"></a>如何分析时间复杂度</h3><h4 id="1-只关注循环执行次数-最多-的代码"><a href="#1-只关注循环执行次数-最多-的代码" class="headerlink" title="1. 只关注循环执行次数 最多 的代码"></a>1. 只关注循环执行次数<span style='color:red'> 最多 </span>的代码</h4><p>大O表示法表示的是<strong>变化趋势</strong>，因此<strong>忽略</strong>常量，低阶，系数，<strong>只</strong>记录<strong>最大量级</strong>；也就是说一段算法中，我们<strong>关注</strong>循环执行次数<strong>最多</strong>的一段即可。</p><pre class=" language-lang-c"><code class="language-lang-c"> int cal(int n) {   int sum = 0; //执行一次   int i = 1; //执行一次   for (; i <= n; ++i) { //执行n次     sum = sum + i; //执行n次   }   return sum; }//那么这关注执行次数最多的代码 这里执行最多的是n次 也就表示为 O(n)</code></pre><h4 id="2-加法法则：总复杂度等于量级最大的那段代码的复杂度"><a href="#2-加法法则：总复杂度等于量级最大的那段代码的复杂度" class="headerlink" title="2. 加法法则：总复杂度等于量级最大的那段代码的复杂度"></a>2. 加法法则：<span style='color:red'>总复杂度</span>等于<span style='color:red'>量级最大</span>的那段代码的复杂度</h4><pre class=" language-lang-c"><code class="language-lang-c">int cal(int n) {   //这里是T1   int sum_1 = 0;  // 执行1次   int p = 1; // 执行1次   for (; p <= 100; ++p) { //执行 100 次     sum_1 = sum_1 + p;  //执行 100 次   }   //那么这一段执行最多的表示 100次 也就是常量 常量一般直接表示O(1)即可    //这里是T2   int sum_2 = 0; // 执行 1 次   int q = 1; // 执行 1 次   for (; q <= n; ++q) { //执行 n 次     sum_2 = sum_2 + q; //执行 n 次   }   //这里一段执行最多的表示 n 次 那么表示为 O(n)   //这里是T3   int sum_3 = 0; // 执行一次   int i = 1; // 执行一次   int j = 1; // 执行一次   for (; i <= n; ++i) { //执行 n 次     j = 1;  // 执行 n 次     for (; j <= n; ++j) { // 执行 n * n 次       sum_3 = sum_3 +  i * j; // 执行 n * n 次     }   }   //这里一段执行最多的表示 n * n 次 那么表示O(n^2)   return sum_1 + sum_2 + sum_3; }</code></pre><p>上面这段代码我们分别假设为$ T1(n) $, $ T2(n) $,$ T3(n)$;那么$ T1(n) $的复杂度为$ O(1) $,$ T(2) $的复杂度为$ O(n) $,$ T(3) $的复杂度为$ O(n^2) $;由此我们可以知道$ T(n) = T1(n) + T2(n) + T3(n) $,那么最终的 $ T(n) = max(O(1),O(n),O(n^2))  $那么我们就可以知道这段代码的$ T(n) = O(n^2) $。</p><h4 id="3-乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"><a href="#3-乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积" class="headerlink" title="3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"></a>3. 乘法法则：<span style='color:red'>嵌套代码的复杂度</span>等于嵌套<span style='color:red'>内外</span>代码复杂度的<span style='color:red'>乘积</span></h4><pre class=" language-lang-c"><code class="language-lang-c">int cal(int n) {   int ret = 0;  //这里执行1次   int i = 1; //这里执行 1 次   for (; i < n; ++i) { //这里执行n次     ret = ret + f(i); //这里执行n次   }  } //这一段代码执行最多的表示 n 次 那么 表示 O(n) int f(int n) {  int sum = 0; //这里执行1次  int i = 1; // 这里执行1次  for (; i < n; ++i) { //这里执行 n 次    sum = sum + i; // 这里执行 n 次  }   return sum; //这里执行1次  //那么这一段代码中最多的执行为 n 次 那么 表示 O(n) }/*这里我们注意第6行这里其实嵌套了f(n)的表达式 那么 最终这段其实真正执行为 O(n) * O(n) 也就是 O(n^2)*/</code></pre><p>上面这段代码最有<strong>争议</strong>的地方就是<strong>第6行</strong>这里我们如果假设$ f(n) $只是普通操作那么执行次数为<strong>n</strong>次，但是这里<strong>明显</strong>知道利用的是下面的$ f(n) $函数因此，这里我们要<strong>先</strong>计算$ f(n) $的<strong>时间复杂度</strong>为$ O(n) $, 然后由于这个是<strong>嵌套</strong>在一个循环代码块中，所以最终就是:</p><script type="math/tex; mode=display">T(n) = O(n) * O(n) = O(n^2)</script><h2 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h2><p><img src="https://static001.geekbang.org/resource/image/37/0a/3723793cc5c810e9d5b06bc95325bf0a.jpg" alt="复杂度量级"></p><p>这里的复杂度可以分为<strong>两类</strong>一类是<strong>多项式量级</strong>，一类是<strong>非多项式量级</strong>；<strong>非多项式量级</strong>只有两个为$ O(2^n) $和$ O(n!) $,其余都是<strong>多项式量级</strong>。</p><p><strong>注</strong>:<strong>非多项式量级</strong>的算法问题称为<strong>NP(Non-Deterministic Polynomial,非确定多项式)</strong>问题。</p><h3 id="1-O-1"><a href="#1-O-1" class="headerlink" title="1. $ O(1) $"></a>1. $ O(1) $</h3><pre class=" language-lang-c"><code class="language-lang-c"> int i = 8; //执行一次 int j = 6; // 执行一次 int sum = i + j; // 执行一次 for(int i = 0 ; i < 100 ; i++){ //执行100次     // }</code></pre><p>$ O(1) $说明只要算法<span style='color:red'>不存在</span><strong>循环语句</strong>，<strong>递归语句</strong>，那么即使有<strong>成千上万</strong>行代码，其<strong>时间复杂度</strong>表示为$  O(1)  $。</p><h3 id="2-O-logn-、O-nlogn"><a href="#2-O-logn-、O-nlogn" class="headerlink" title="2. $ O(logn)、O(nlogn) $"></a>2. $ O(logn)、O(nlogn) $</h3><pre><code> i=1; //执行一次 while (i &lt;= n)  {    i = i * 2; //执行2^n次 }</code></pre><p>这个比较难理解，看下图:</p><p><img src="https://static001.geekbang.org/resource/image/9b/9a/9b1c88264e7a1a20b5954be9bc4bec9a.jpg" alt="指数增长"></p><p>由这个图我们可以得到$ n = 2 ^ x$那么我们解$ x $得到$ x = log_2n $,那么上面那段代码的<strong>时间复杂度</strong>就是$ O(log_2n) $。</p><pre class=" language-lang-c"><code class="language-lang-c"> i=1; while (i <= n)  {   i = i * 3; }</code></pre><p>由这个例子我们可以得到$ n = 3 ^ x $也就是解$ x $可以得到$ x = log_3n $，那么这段代码的<strong>时间复杂度</strong>就是$ O(log_3n) $；<strong>但是</strong>，由于<strong>对数</strong>可以相互转化所以这里都简写成$ O(logn) $了。</p><pre><code>int cat(int n){ int sum = 0; for(int i = 0 ; i &lt; n ; i++){     sum = sum + f(i); }}int f(int n){    int i = 1;    while(i &lt;= n){        i = i * 2;    }}</code></pre><p>上面我们知道<strong>乘法法则</strong>，那么$ O(nlogn) $就很好理解了，上面的代码<strong>函数</strong>$ f(n) $执行了$ O(logn) $,在<strong>函数</strong>$ cat(n) $中 <code>sum = sum + f(i)</code>这里就知道了</p><script type="math/tex; mode=display">O(n) = O_c(n) * O_f(n) = O(n) * O(logn) = O(nlogn)</script><h3 id="3-O-m-n-、O-m-n"><a href="#3-O-m-n-、O-m-n" class="headerlink" title="3. $ O(m+n)、O(m*n) $"></a>3. $ O(m+n)、O(m*n) $</h3><pre><code>int cal(int m, int n) {  int sum_1 = 0; //这里执行1次  int i = 1; //这里执行1次  for (; i &lt; m; ++i) { //这里执行m次    sum_1 = sum_1 + i; //这里执行m次  }  int sum_2 = 0; //这里执行1次  int j = 1; //这里执行1次  for (; j &lt; n; ++j) { //这里执行n次    sum_2 = sum_2 + j; //这里执行n次  }  return sum_1 + sum_2;}</code></pre><p>上面的这段代码我们可以看到有<strong>两个</strong>循环结构他们循环的次数<strong>各不相同</strong>一个是<strong>n</strong>次还有一个是<strong>m</strong>次，因为无法<strong>事先评估</strong>m和n的次数，所以计算这种<strong>时间复杂度</strong>的时候，我们得出的结果为:</p><script type="math/tex; mode=display">O(N) = O(m) + O(n) = O(m+n)</script><p>对于$ O(m * n) $其实就很容易了，可以参考下面的代码：</p><pre class=" language-lang-c"><code class="language-lang-c">int cal(int n) {   int ret = 0;  //这里执行1次   int i = 1; //这里执行 1 次   for (; i < m; ++i) { //这里执行m次     ret = ret + f(i); //这里执行m次   }  } //这一段代码执行最多的表示 n 次 那么 表示 O(n) int f(int n) {  int sum = 0; //这里执行1次  int i = 1; // 这里执行1次  for (; i < n; ++i) { //这里执行 n 次    sum = sum + i; // 这里执行 n 次  }   return sum; //这里执行1次  //那么这一段代码中最多的执行为 n 次 那么 表示 O(n) }</code></pre><p>这里我们可以计算得到：</p><script type="math/tex; mode=display">O(N) = O(m) * O(n) = O(m*n)</script><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>由于<strong>空间复杂度</strong>和<strong>时间复杂度</strong>基本上类似，所以这里给出一个定义<strong>表示算法的存储空间与数据规模之间的增长关系</strong>,全称<strong>渐进空间复杂度</strong>。</p><p>比如 <code>int [] a = new int[n]</code>那么这段就说明<strong>空间复杂度</strong>为$ O(n) $。</p><h2 id="复杂度的比较图"><a href="#复杂度的比较图" class="headerlink" title="复杂度的比较图"></a>复杂度的比较图</h2><p><img src="https://static001.geekbang.org/resource/image/49/04/497a3f120b7debee07dc0d03984faf04.jpg" alt="复杂度比较图"></p><h1 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h1><h2 id="你为什么要学习数据结构和算法呢？"><a href="#你为什么要学习数据结构和算法呢？" class="headerlink" title="你为什么要学习数据结构和算法呢？"></a>你为什么要学习数据结构和算法呢？</h2><p>作为一个学生党，对于数据结构和算法的了解仅仅只是在蓝桥杯比赛中实际运用过，但是听过很多前辈与学长的教诲都说明了其重要性，前段时间买了慕课网的一门课程，在学习时知道这些基础的知识对编程的原理掌握以及看懂开源框架十分的重要，因此要花费时间学习这些知识。</p><h2 id="在过去的软件开发中，数据结构和算法在哪些地方帮到了你？"><a href="#在过去的软件开发中，数据结构和算法在哪些地方帮到了你？" class="headerlink" title="在过去的软件开发中，数据结构和算法在哪些地方帮到了你？"></a>在过去的软件开发中，数据结构和算法在哪些地方帮到了你？</h2><p>对于这个问题，作为一个学生其实这个对我的帮助并不多，因为我没参加过实际的项目开发，也不懂得实际的项目开发经验，现在唯一给我帮助的地方就只有当时参加<strong>蓝桥杯</strong>比赛，让我从比赛中获得了<strong>省赛一等</strong>的成绩，为后面申请<strong>国家奖学金</strong>给了一些帮助。</p><h2 id="项目运行时会做性能测试，我们有必要进行时间与空间的复杂度分析呢？"><a href="#项目运行时会做性能测试，我们有必要进行时间与空间的复杂度分析呢？" class="headerlink" title="项目运行时会做性能测试，我们有必要进行时间与空间的复杂度分析呢？"></a>项目运行时会做性能测试，我们有必要进行时间与空间的复杂度分析呢？</h2><p>虽然项目运行的时候会进行性能相关的测试，但是我们也有必要进行相关的时间与空间复杂度分析，我们可以对一些及其影响性能的功能代码进行分析，因为这些代码对性能要求极高，越节省对后面跑大规模的数据越有利。</p><h2 id="对每段代码分析时间与空间复杂度，是否会浪费时间？"><a href="#对每段代码分析时间与空间复杂度，是否会浪费时间？" class="headerlink" title="对每段代码分析时间与空间复杂度，是否会浪费时间？"></a>对每段代码分析时间与空间复杂度，是否会浪费时间？</h2><p>对每段代码的分析，可能浪费时间了，因为并不是每段代码都涉及到大量的操作，可能有些代码并不常执行，因此对一些重要的代码可以进行时间与空间的复杂度分析，毕竟有一个工种就叫算法工程师，虽然他们大部分可能涉及代码研究，但是对于一些代码的优化也是他们工种的工作内容之一。</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法之美 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用Git</title>
      <link href="/archives/ab8e450c.html"/>
      <url>/archives/ab8e450c.html</url>
      
        <content type="html"><![CDATA[<!-- 这里注释一上面可能常用的东西 --><!-- toc用于目录的展开默认无需更改 --><!-- tags与categories 一个是标签一个是文章分类 标签可以有多个 文章分类只能有一个 要注意 直接后面添加即可 --><!-- top 默认 false 这个是用来推荐文章的 --><!-- mathjax 默认是 false 如果以后要用到数学公式可以开启 --><!-- summary 写得是关于文章的摘要 --><!-- password用于对文章进行加密 这里需要利用SHA256算法加密 这里给个加密网址  https://tool.oschina.net/encrypt?type=2 --><h1 id="相关软件"><a href="#相关软件" class="headerlink" title="相关软件"></a>相关软件</h1><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>Git是一个开源分布式版本控制系统，简单来说就如同<strong>系统备份</strong>可以备份你写的代码，并且可以回溯你之前的代码。</p><h2 id="SourceTree"><a href="#SourceTree" class="headerlink" title="SourceTree"></a>SourceTree</h2><p>SourceTree是一个<strong>图形化</strong>的Git客户端，简单来说就是能够让我们通过像操作Windows那样更加容易的完成自己的代码版本控制。</p><h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h2><p>Git的下载需要到其官网下载，这里给出其Windows版本的链接<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Git For Windows</a>，直接点击<strong>Click here to download manually</strong>即可下载适合自己版本的Git,至于安装无脑下一步即可。</p><h2 id="SourceTree安装"><a href="#SourceTree安装" class="headerlink" title="SourceTree安装"></a>SourceTree安装</h2><p>SourceTree的下载同样在其<a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">官方网站</a>能够下载到，由于我自己已经安装了SourceTree所以这里给出<a href="https://www.jianshu.com/p/dce21c4e88fc" target="_blank" rel="noopener">SourceTree安装（小白特别详细教程）</a>。</p><h1 id="创建属于自己的远程仓库"><a href="#创建属于自己的远程仓库" class="headerlink" title="创建属于自己的远程仓库"></a>创建属于自己的远程仓库</h1><ol><li>在创建自己的远程仓库之前，我们需要拥有自己的GitHub账号，登录 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>既可以创建，这里推荐<strong>谷歌浏览器</strong>因为其自带翻译功能，毕竟对于新手来说，英语也是一个门槛，在完成自己账号的创建登录之后选择上方的<strong>加号</strong>，选择<strong>New repository</strong>  </li></ol><p><img src="https://s1.ax1x.com/2020/07/11/UQEHaQ.png" alt="UQEHaQ.png"></p><ol><li>跳转页面后在<strong>Repository name</strong>中填入自己的仓库名，<strong>Description</strong>中填入对此仓库的描述，这里注意的是由于初期我们使用的是<strong>SourceTree</strong>因此勾选<strong>Initialize this repository with a README</strong>可以减少对仓库的初始化操作，交由Github完成，最后点击<strong>Create repository</strong>即可创建自己的GitHub远程仓库。</li></ol><p><img src="https://s1.ax1x.com/2020/07/11/UQEoqS.png" alt="UQEoqS.png"></p><ol><li>创建完成后，选择<strong>Code</strong>按钮，在<strong>Clone With HTTPS</strong>中会给出一个<strong>URL</strong>链接，复制这个链接即可。<br>Note:当然这里也可以选择<strong>Use SSH</strong>,通过SSH密钥的方式登入，这里不做赘述。</li></ol><p><img src="https://s1.ax1x.com/2020/07/11/UQE7Vg.png" alt="UQE7Vg.png"></p><ol><li>在本地打开我们的<strong>SourceTree</strong>按住<strong>Ctrl+N</strong>打开一个页面，选择上方的<strong>Clone</strong>填入<strong>URL</strong>以及<strong>本地保存路径</strong>点击<strong>克隆</strong>即可</li></ol><p><img src="https://s1.ax1x.com/2020/07/11/UQEIr8.png" alt="UQEIr8.png"></p><h1 id="相关引用与推荐"><a href="#相关引用与推荐" class="headerlink" title="相关引用与推荐"></a>相关引用与推荐</h1><ol><li><a href="https://blog.csdn.net/qq_38232598/article/details/91346392" target="_blank" rel="noopener">解决Github网页上图片显示失败的问题</a></li><li><a href="https://www.jianshu.com/p/11bba2b1e95d" target="_blank" rel="noopener">SourceTree 入门教程</a></li><li><a href="https://blog.csdn.net/weixin_38419133/article/details/89412755?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-8.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-8.edu_weight" target="_blank" rel="noopener">如何在Github 的README.md文件中添加图片</a></li><li><span style='color:red'> *强烈推荐 </span>  <a href="https://www.imooc.com/learn/1052" target="_blank" rel="noopener">Git入门</a> <em>这个教程里面有Git命令方法与SourceTree使用方法，开始可以挑选SourceTree的方法</em></li><li><span style='color:red'> *强烈推荐 </span> <a href="https://mp.weixin.qq.com/s?__biz=MzU4NTIxODYwMQ==&amp;mid=2247483856&amp;idx=1&amp;sn=47a72cee1190aefc06c24fea78f78484&amp;chksm=fd8cae96cafb2780f2634bbeece1608f321ea2698523869ff6d0c58497ad2dfbf5fa1233b0dd&amp;token=88683563&amp;lang=zh_CN#rd" target="_blank" rel="noopener">天生不聪明</a> <em>大牛的软文，可以看看参考一哈，也是本课程的作者</em></li><li><span style='color:red'> *强烈推荐</span> <a href="https://mp.weixin.qq.com/s?__biz=MzU4NTIxODYwMQ==&amp;mid=2247483836&amp;idx=1&amp;sn=90854aa76507281403e4dd9cd434a12b&amp;chksm=fd8caefacafb27ec78f999fde4f1217c04c6e2ff28cf51fe511d8fa29d484d9281ff91de8c9c&amp;token=88683563&amp;lang=zh_CN#rd" target="_blank" rel="noopener">如果高效学习有什么秘诀的话，那就都在这里了</a> <em>同上</em></li></ol><h1 id="后续补充-—-这里是后续会补充的内容-当然暂时是不会补充了"><a href="#后续补充-—-这里是后续会补充的内容-当然暂时是不会补充了" class="headerlink" title="后续补充 — 这里是后续会补充的内容 当然暂时是不会补充了"></a>后续补充 — 这里是后续会补充的内容 <del>当然暂时是不会补充了</del></h1><ol><li>markdown的使用与安装</li><li>如何使用GitBush进行操作</li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> Git </tag>
            
            <tag> SourceTree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github+Hexo搭建博客教程</title>
      <link href="/archives/19f3ab51.html"/>
      <url>/archives/19f3ab51.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为毕业了，所以为了以后能够有一个记录的博客，所以花费了一段时间，搭建了一个利用GitHub+Hexo实现的个人博客<del>(最大的原因是因为可以白嫖)</del> ，但是之前使用的博客没有用过Markdown进行相关的内容写作，因此教程可能有些地方并不美观，还请各位小伙伴能够见谅，有问题也可以在下方留言，有时间我会回答的。</p><p>首先我们要了解一下我们搭建博客需要使用的框架Hexo，这个框架是一个高效的静态站点生成框架，基于Node.js。通过这个框架我们可以利用MarkDown语法来撰写自己的博客内容，并且写文章，除了没有可视化管理界面以外一切都很方便(这个问题可以用插件解决)，废话少说下面介绍。</p><h1 id="准备与安装"><a href="#准备与安装" class="headerlink" title="准备与安装"></a>准备与安装</h1><p>在这搭建自己的博客之前我们需要完成三个主要的步骤，首先要拥有你自己的<strong>Github账号</strong>其次要在你的系统中安装好<strong>Git</strong>以及<strong>Node.js</strong>。</p><h2 id="Github的注册"><a href="#Github的注册" class="headerlink" title="Github的注册"></a>Github的注册</h2><p><a href="https://www.github.com" target="_blank" rel="noopener">Github</a> 的注册网上有很多的教程，由于我自己已经有了一个Github账号，因此这里给出网上比较新的注册教程，虽然GIthub网站是英文的网站，但是一般的浏览器都自带翻译功能，相信这个难不倒各位————<a href="https://blog.csdn.net/JCtry/article/details/107191143" target="_blank" rel="noopener">Gihub注册教程</a></p><h2 id="Git的安装"><a href="#Git的安装" class="headerlink" title="Git的安装"></a>Git的安装</h2><p>因为我们需要把自己本地仓库的内容上传到Github上面去，所以我们可能需要用到版本控制工具<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a>，由于这个工具并不是GUI工具所以可能需要学习一些命令，本文需要用到的命令下面都会标出，这里同样给出一个<a href="https://blog.csdn.net/aiwst/article/details/106924863" target="_blank" rel="noopener">Git的安装教程</a>照着安装即可。</p><p><strong>Note：</strong></p><p>​    这里提示一下，添加路径的时候要选择 <code>Use Git from the Windows Command Prompt</code>,这样做的好处可以让我们在Windows的控制台打开Git。安装完成之后Windows系统下按住<code>Win+R</code>输入<code>cmd</code>打开控制台输入<code>git --version</code>验证是否安装成功，效果如下图：</p><p><img src="https://s1.ax1x.com/2020/07/10/UuXJvq.png" alt="UuXJvq.png" style="zoom:85%;" /></p><h2 id="Node-js的安装"><a href="#Node-js的安装" class="headerlink" title="Node.js的安装"></a>Node.js的安装</h2><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>安装就比较简单了直接点击<a href="https://nodejs.org/dist/v12.18.2/node-v12.18.2-x64.msi" target="_blank" rel="noopener">下载</a>其实就可以了，我这里给出的是长期支持的x64版本如果需要其他版本可以上官网查看，安装只需要一路Next即可。</p><p>安装完成之后Windows系统下按住<code>Win+R</code>输入<code>cmd</code>打开控制台,输入 <code>node -v</code> 和 <code>npm - v</code> ,如果出现版本号，就安装成功了，如下图：</p><p><img src="https://s1.ax1x.com/2020/07/10/UuXfaD.png" alt="UuXfaD.png"></p><p>当上面的步骤完成之后，我们就可以开始利用我们的Github搭建我们自己的免费博客了！</p><h1 id="GithubPage设置"><a href="#GithubPage设置" class="headerlink" title="GithubPage设置"></a>GithubPage设置</h1><h2 id="GithubPage仓库创建"><a href="#GithubPage仓库创建" class="headerlink" title="GithubPage仓库创建"></a>GithubPage仓库创建</h2><p>GithubPage是Github提供的一个搭建博客的功能，利用这个我们可以免费搭建属于自己的个人博客，打开<a href="https://github.com" target="_blank" rel="noopener">https://github.com</a> ,新建一个项目，如图所示：</p><p><img src="https://s1.ax1x.com/2020/07/10/UujmW9.png" alt="UujmW9.png"></p><p>之后输入自己的项目名字，项目名为 <code>创建的用户名.github.io</code> 注意的是这里的 <code>.github.io</code> 不能少，同样的你的用户名必须和你的<strong>Github用户名</strong>完全一致，不能改动，例如我这里的账号叫 <code>PertalDemoTest</code> ,那么我创建的 <code>repository</code> 名称就叫 <code>PertalDemoTest.github.io</code> , 下面的 <code>Description</code> 用来填写对这个仓库的描述，其他默认即可，当然这里可以<strong>勾选</strong><code>Initialize this repository with a ReADME</code>，这样可以直接初始化，这里我就不勾选了。</p><p><img src="https://s1.ax1x.com/2020/07/10/UKSBcj.png" alt="UKSBcj.png"></p><p>创建完成之后，出现的界面如下所示:</p><p><img src="https://s1.ax1x.com/2020/07/10/UKSqUK.png" alt="UKSqUK.png" style="zoom:50%;" /></p><p>到这里基本的仓库创建就完成了。</p><h2 id="如何利用Git进行初始化"><a href="#如何利用Git进行初始化" class="headerlink" title="如何利用Git进行初始化"></a>如何利用Git进行初始化</h2><p>完成了仓库的创建之后，我们需要对我们自己新建的这个仓库进行一个初始化，这里首先在本地新建一个文件夹用来保存后续上传到仓库的配置，对文件夹<strong>鼠标右键</strong>后选择<strong>Git Bash Here</strong>弹出Git的界面后，我们首先进行c初始化输入 <code>git init</code> 之后一下设置用户名和邮箱的设置，这里分别输入 <code>git config user.name &quot;你的Github用户名&quot;</code> 和 <code>git config user.email &quot;你创建的Github账户邮箱&quot;</code> 当然 如果你只有一个账户的话可以直接设置 <code>git config --global user.name &quot;你的Github用户名&quot;</code>和 <code>git config --global user.email &quot;你创建的Github账户邮箱&quot;</code> 设置完成。</p><p><img src="https://s1.ax1x.com/2020/07/10/UKPWZR.png" alt="UKPWZR.png"></p><p>这里我们使用<strong>SSH</strong>的登入方式，因为这种登录方式比较简单，直接输入 <code>ssh-keygen -t rsa -C &quot;你的电子邮箱&quot;</code>即可，然后一路回车，如果碰到有<strong>(y/n)</strong>打一个<strong>y</strong>继续回车，这样我们就生成了自己的SSH密钥。</p><p><img src="https://s1.ax1x.com/2020/07/10/UKimWT.png" alt="UKimWT.png"></p><p>然后打开你的Github找到<strong>Settings</strong>，找到<strong>SSH and GPG keys</strong>点击<strong>New SSH key</strong>之后到你的 <code>C:/用户/你的用户名/.ssh</code>下找到<code>id_rsa.pub</code>文件利用<strong>记事本</strong>打开复制里面的内容，放入刚刚的页面中，这里的<strong>Title</strong>可以随意，如下图所示：</p><p><img src="https://s1.ax1x.com/2020/07/10/UKkSKg.png" alt="UKkSKg.png"></p><p><img src="https://s1.ax1x.com/2020/07/10/UKATAA.png" alt="UKATAA.png"></p><p>同时这里设置一下，可能需要输入一下自己的密码，验证一下，之后我们在控制台中输入 <code>ssh -T git@github.com</code> 出现下图提示就成功了。</p><p><img src="https://s1.ax1x.com/2020/07/10/UKZxBD.png" alt="UKZxBD.png"></p><p>需要注意的是后面提示没有提供<strong>shell access</strong>这里我们需要在个人账户的设置中找到<strong>Email</strong>设置下将<strong>Keep my email address private</strong>的勾选取消，然后在<strong>Profile</strong>设置中找到<strong>Public email</strong>选择自己的邮箱拉到下面点击<strong>Update profile</strong>解决后面<strong>无法push</strong>的问题。</p><p>接下来我们可以参照<strong>Github的提示</strong>测试一下连接我们的远程仓库</p><p><img src="https://s1.ax1x.com/2020/07/10/UKmjTe.png" alt="UKmjTe.png"></p><p><a href="https://imgchr.com/i/UKnmfs" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/10/UKnmfs.png" alt="UKnmfs.png"></a></p><p>之后刷新一下我们的仓库，可以看到一个<code>README.md</code>文件，到这里我们已经完成了本地与远程仓库的连接。</p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>接下来，刷新一下我们的仓库页面，找到<strong>Settings</strong>下拉找到<strong>GitHub Pages</strong>点击<strong>Choose a theme</strong>选择一个喜欢的主题，选择<strong>Select theme</strong>然后在网址框中输入<code>你的用户名.github.io</code>可以发现已经有一个页面的雏形了。</p><p><img src="https://s1.ax1x.com/2020/07/10/UKuZDK.png" alt="UKuZDK.png"></p><p>接下来我们就开始安装Hexo,在Git控制台中输入 <code>npm i hexo-cli -g</code> ，可能会有<strong>WARN</strong>这里可以直接无视，接下来输入 <code>hexo init</code> 进行初始化，然后输入 <code>npm install</code> 安装必备组件，这里可能有报错，我们可以将隐藏的 <code>.git</code>先移到别处删除我们刚刚创建的<code>REAMD.md</code>文件,等待安装结束后在移回来，接下来我们输入 <code>hexo g</code> 和 <code>hexo s</code> 然后浏览器输入<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> , 就可以看到我们的博客啦，效果如下：</p><p><img src="https://s1.ax1x.com/2020/07/10/UK1iXn.png" alt="UK1iXn.png"></p><p>到这里整个博客就算搭建完成了，接下来我们就可以写我们自己的文章了。</p><h1 id="写文章，发布文章"><a href="#写文章，发布文章" class="headerlink" title="写文章，发布文章"></a>写文章，发布文章</h1><p>首先安装一个扩展 <code>npm i hexo-deployer-git</code> 然后输入 <code>hexo new &quot;文章名&quot;</code>就可以创建一篇文章啦，之后打开 <code>根目录/source/_posts</code>里面就可以发现创建好的文章，这里编写文章可能需要学习一下MarkDown，并且下载一个支持<code>.md</code>文件的程序，这里我用的是<a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a>,当然市面还有其他各类的软件，这里就看个人喜好进行选择了，编写完成后 打开<strong>根目录</strong>下的 <code>_config.yml</code> 文件修改<strong>deploy</strong>后保存。</p><pre><code>deploy:  type: git  repository: https://github.com/你的github用户名/你的github用户.github.io  branch: master</code></pre><p> <code>hexo g</code> 生成文件然后<code>hexo d</code>就可以将自己的文章发布到网站上了，输入 <code>用户名.github.io</code> 就可以访问自己刚刚生成的文章了，到这里基本的博客就搭建完成了。</p><h1 id="个性化设置"><a href="#个性化设置" class="headerlink" title="个性化设置"></a>个性化设置</h1><p>这里埋一个坑，内容很多，慢慢填坑…</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生命不息,折腾不止.---记我自己的路</title>
      <link href="/archives/83a0a85.html"/>
      <url>/archives/83a0a85.html</url>
      
        <content type="html"><![CDATA[<p>​    呼，花了两天的时间，终于用GithubPages和Hexo完成了自己个人博客的搭建，其实之前的三年也搭建过不止一次博客，但是最后都不了了之。原因也很简单，就是觉得写博客很烦，维护博客并且找到心仪的博客主题很难，其实更多的还是自己懒，懒得让自己一直都呆在舒适圈内，一直跌跌撞撞的在徘徊的路上。从自己开始学习编程到现在其实已经过去了6年多了，但是这6年我并没有做出什么拿的出手的项目，也并没有精通一门语言: Python, C/C++, C#, Java 其中除了Java是最近一段时间学习的以外其他都只是在门外打转。买了一堆书，发了一堆誓，打了多次的鸡血，最后泄气之后一事无成，人生好像就是这样起起伏伏的样子，也是因为这样不断的重复，不断的经历，我慢慢不再追求那种完美，开始听信别人的话。</p><p>​    固执，钻牛角，随意答应别人的请求而不去执行，这个毛病在这几年内多次给了我教训，但是每次教训之后我这鱼一样的记忆力让我再次重蹈覆辙，就这样一晃三年过去，我毕业了同样也升学了，大专三年，给我带来了很多的感触也让我确定了自己的人生目标，所以每个时刻的自己真的有着不同的想法，不同的感悟。</p><p>​    现在作为一个还有假期的学生，在此时此刻我写下了自己的一点感慨，其实都算不上感慨，只是自己一时间的想法罢了，毕竟未来我很期待，但是同样的未来的自己又如何，我也不清楚，但是就如同标题一样，我希望未来的自己，生命不息，折腾不止，走出自己的路。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录感悟 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
