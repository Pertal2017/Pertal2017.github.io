<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法学习记录-1</title>
      <link href="/archives/a146fb38.html"/>
      <url>/archives/a146fb38.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这个文章系列主要用来记录自己学习算法与数据结构的相关记录，期望自己可以每日都写，但是具体的话还是根据实际学习的情况来，主要是用来总结，也算是用来强迫鞭策自己进行知识内容的输出，毕竟学习这些内容是枯燥的，利用各种资源加上自己的总结来让自己更加了解这方面的知识对未来并没有什么坏处。</p><h1 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h1><h2 id="算法与数据结构概念"><a href="#算法与数据结构概念" class="headerlink" title="算法与数据结构概念"></a>算法与数据结构概念</h2><ol><li><strong>算法</strong>表示操作数据的一组方法。</li><li><strong>数据结构</strong>表示一组数据的存储结构。</li><li><strong>狭义上</strong> 两者差不多主要是由前人总结下来的一些实际操作场景中的抽象方法，用来解决实际开发问题。</li><li><strong>两者关系</strong>相辅相成，数据结构为算法<strong>服务</strong>，算法主要作用在特定的数据结构之上。</li></ol><h2 id="大O复杂度表示法"><a href="#大O复杂度表示法" class="headerlink" title="大O复杂度表示法"></a>大O复杂度表示法</h2><h3 id="如何理解大O复杂度表示法"><a href="#如何理解大O复杂度表示法" class="headerlink" title="如何理解大O复杂度表示法"></a>如何理解大O复杂度表示法</h3><p>第一个简单代码分析</p><pre class=" language-c"><code class="language-c"> <span class="token comment" spellcheck="true">//这里假设的是每行执行时间为time</span> <span class="token keyword">int</span> <span class="token function">cal</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 这里为 1 * time</span>   <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这里为 2 * time </span>   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 这里分析主要执行的操作是++i操作 要执行n次 因为 i &lt;= n</span>     <span class="token comment" spellcheck="true">//在这个里面的代码块执行是一个循环结构</span>     sum <span class="token operator">=</span> sum <span class="token operator">+</span> i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这里执行的操作是n次</span>   <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">//循环结束之后 这里总共执行 2n * time次</span>   <span class="token comment" spellcheck="true">// 那么不算最后的输出 在这个内部函数逻辑里面它的总共执行次数为 (2n+2) * time</span>   <span class="token keyword">return</span> sum<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>这里对 <code>for(;i&lt;=n;i++)</code> 的循环块代码利用另一种<strong>循环结构</strong>的分析</p><pre class=" language-c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//这里的if判断说明的是当i > n之后跳出这个循环</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">></span> n<span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//这个操作其实是 i = i + 1; 那么通过上面的条件就知道这个要执行 n 次</span>    <span class="token keyword">else</span>         <span class="token operator">++</span>i<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//这个操作是在循环块代码内部那么执行 n 次</span>    sum <span class="token operator">=</span> sum <span class="token operator">+</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 因此最后这个循环体执行n + n 次的操作 也就是 2n</span></code></pre><p>第二个部分的代码分析</p><pre class=" language-c"><code class="language-c"> <span class="token comment" spellcheck="true">//这里假设的是每行执行时间为time</span> <span class="token keyword">int</span> <span class="token function">cal</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这里为 1 * time</span>   <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这里为 2 * time</span>   <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这里为 3 * time</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//这里分析主要执行的是++i操作 要执行n次 因为 i &lt;= n</span>     <span class="token comment" spellcheck="true">// 这里是循环代码的内部操作</span>     j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这里执行的操作是n次</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//这里分析主要执行的是++j操作 要执行n次 但是它在循环操作里面 所以就是 n*n次</span>       <span class="token comment" spellcheck="true">//这里是循环代码的内部操作</span>       sum <span class="token operator">=</span> sum <span class="token operator">+</span>  i <span class="token operator">*</span> j<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这里执行的操作是n*n次</span>     <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">//跳出这个循环后这里总共执行n*n + n*n 也就是 2n^2</span>   <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//跳出这个循环后 这里总共执行 2n + 2n^2</span>    <span class="token comment" spellcheck="true">//那么这个函数加在一起总共执行了 (2n^2 + 2n + 3) * time</span> <span class="token punctuation">}</span></code></pre><p>这里同样利用另一种<strong>循环结构</strong>进行分析</p><pre class=" language-c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> n<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//这里主要表示 i > n 的时候 跳出这个循环</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token operator">++</span>i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这里是说如果i &lt;=n 那么执行 i = i + 1;的操作 那么这里总共执行 n 次</span>    j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这里 在循环块内部 那么执行 n次</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">></span> n<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 这里主要表示 j > n 的时候跳出这个循环</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token comment" spellcheck="true">// 这里是说如果 j &lt;= n 的时候执行 j = j + 1的操作 那么在这个循环体内执行 n次 </span>            <span class="token comment" spellcheck="true">// 但是外面还有一个循环体  所以这里这个总共执行n * n次</span>            <span class="token operator">++</span>j<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 这说明 在循环体内执行n次 由于是循环体套循环体所以这里总共执行 n * n次</span>        sum <span class="token operator">=</span> sum <span class="token operator">+</span> i <span class="token operator">*</span> j<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 因此最后这个循环体总共执行的操作是 2n^2 + 2n的操作</span></code></pre><p>从这两个推导我们得到一个规律<strong>所有代码的执行时间T(n)与每行代码的执行次数n成正比</strong>,那么我们可以得到一个公式也就是<br>$$<br>T(n) = O(f(n))<br>$$<br>这里$ T(n) $表示的<strong>代码总共执行时间</strong>；$ n $ 表示的是<strong>数据规模的大小</strong>；$ f(n) $表示的是<strong>每行代码执行的次数总和</strong>；公式中的$ O $用来表示<strong>代码执行时间</strong>$ T(n) $与<strong>执行次数</strong>$ f(n) $表达式成正比。</p><p><strong>注意</strong>：<strong>大O</strong>时间复杂度实际并不表示<strong>具体</strong>表示代码<strong>真正</strong>执行时间，而是表示<strong>代码执行时间</strong>随<strong>数据规模</strong>形成的一种<strong>增长变化趋势</strong>，也可以称为<strong>渐进时间复杂度</strong>，简称<strong>时间复杂度</strong>。</p><h3 id="如何分析时间复杂度"><a href="#如何分析时间复杂度" class="headerlink" title="如何分析时间复杂度"></a>如何分析时间复杂度</h3><h4 id="1-只关注循环执行次数-最多-的代码"><a href="#1-只关注循环执行次数-最多-的代码" class="headerlink" title="1. 只关注循环执行次数 最多 的代码"></a>1. 只关注循环执行次数<span style='color:red'> 最多 </span>的代码</h4><p>大O表示法表示的是<strong>变化趋势</strong>，因此<strong>忽略</strong>常量，低阶，系数，<strong>只</strong>记录<strong>最大量级</strong>；也就是说一段算法中，我们<strong>关注</strong>循环执行次数<strong>最多</strong>的一段即可。</p><pre class=" language-c"><code class="language-c"> <span class="token keyword">int</span> <span class="token function">cal</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//执行一次</span>   <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//执行一次</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//执行n次</span>     sum <span class="token operator">=</span> sum <span class="token operator">+</span> i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//执行n次</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> sum<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//那么这关注执行次数最多的代码 这里执行最多的是n次 也就表示为 O(n)</span></code></pre><h4 id="2-加法法则：总复杂度等于量级最大的那段代码的复杂度"><a href="#2-加法法则：总复杂度等于量级最大的那段代码的复杂度" class="headerlink" title="2. 加法法则：总复杂度等于量级最大的那段代码的复杂度"></a>2. 加法法则：<span style='color:red'>总复杂度</span>等于<span style='color:red'>量级最大</span>的那段代码的复杂度</h4><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">cal</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//这里是T1</span>   <span class="token keyword">int</span> sum_1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 执行1次</span>   <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 执行1次</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> p <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//执行 100 次</span>     sum_1 <span class="token operator">=</span> sum_1 <span class="token operator">+</span> p<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//执行 100 次</span>   <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">//那么这一段执行最多的表示 100次 也就是常量 常量一般直接表示O(1)即可 </span>   <span class="token comment" spellcheck="true">//这里是T2</span>   <span class="token keyword">int</span> sum_2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 执行 1 次</span>   <span class="token keyword">int</span> q <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 执行 1 次</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> q <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>q<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//执行 n 次</span>     sum_2 <span class="token operator">=</span> sum_2 <span class="token operator">+</span> q<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//执行 n 次</span>   <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">//这里一段执行最多的表示 n 次 那么表示为 O(n)</span>   <span class="token comment" spellcheck="true">//这里是T3</span>   <span class="token keyword">int</span> sum_3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 执行一次</span>   <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 执行一次</span>   <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 执行一次</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//执行 n 次</span>     j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 执行 n 次</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 执行 n * n 次</span>       sum_3 <span class="token operator">=</span> sum_3 <span class="token operator">+</span>  i <span class="token operator">*</span> j<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 执行 n * n 次</span>     <span class="token punctuation">}</span>   <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">//这里一段执行最多的表示 n * n 次 那么表示O(n^2)</span>   <span class="token keyword">return</span> sum_1 <span class="token operator">+</span> sum_2 <span class="token operator">+</span> sum_3<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>上面这段代码我们分别假设为$ T1(n) $, $ T2(n) $,$ T3(n)$;那么$ T1(n) $的复杂度为$ O(1) $,$ T(2) $的复杂度为$ O(n) $,$ T(3) $的复杂度为$ O(n^2) $;由此我们可以知道$ T(n) = T1(n) + T2(n) + T3(n) $,那么最终的 $ T(n) = max(O(1),O(n),O(n^2))  $那么我们就可以知道这段代码的$ T(n) = O(n^2) $。</p><h4 id="3-乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"><a href="#3-乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积" class="headerlink" title="3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"></a>3. 乘法法则：<span style='color:red'>嵌套代码的复杂度</span>等于嵌套<span style='color:red'>内外</span>代码复杂度的<span style='color:red'>乘积</span></h4><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">cal</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//这里执行1次</span>   <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这里执行 1 次</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//这里执行n次</span>     ret <span class="token operator">=</span> ret <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这里执行n次</span>   <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//这一段代码执行最多的表示 n 次 那么 表示 O(n)</span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这里执行1次</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这里执行1次</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//这里执行 n 次</span>    sum <span class="token operator">=</span> sum <span class="token operator">+</span> i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这里执行 n 次</span>  <span class="token punctuation">}</span>   <span class="token keyword">return</span> sum<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这里执行1次</span>  <span class="token comment" spellcheck="true">//那么这一段代码中最多的执行为 n 次 那么 表示 O(n)</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*这里我们注意第6行这里其实嵌套了f(n)的表达式 那么 最终这段其实真正执行为 O(n) * O(n) 也就是 O(n^2)*/</span></code></pre><p>上面这段代码最有<strong>争议</strong>的地方就是<strong>第6行</strong>这里我们如果假设$ f(n) $只是普通操作那么执行次数为<strong>n</strong>次，但是这里<strong>明显</strong>知道利用的是下面的$ f(n) $函数因此，这里我们要<strong>先</strong>计算$ f(n) $的<strong>时间复杂度</strong>为$ O(n) $, 然后由于这个是<strong>嵌套</strong>在一个循环代码块中，所以最终就是:<br>$$<br>T(n) = O(n) * O(n) = O(n^2)<br>$$</p><h2 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h2><p><img src="https://static001.geekbang.org/resource/image/37/0a/3723793cc5c810e9d5b06bc95325bf0a.jpg" alt="复杂度量级"></p><p>这里的复杂度可以分为<strong>两类</strong>一类是<strong>多项式量级</strong>，一类是<strong>非多项式量级</strong>；<strong>非多项式量级</strong>只有两个为$ O(2^n) $和$ O(n!) $,其余都是<strong>多项式量级</strong>。</p><p><strong>注</strong>:<strong>非多项式量级</strong>的算法问题称为<strong>NP(Non-Deterministic Polynomial,非确定多项式)</strong>问题。</p><h3 id="1-O-1"><a href="#1-O-1" class="headerlink" title="1. $ O(1) $"></a>1. $ O(1) $</h3><pre class=" language-c"><code class="language-c"> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//执行一次</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 执行一次</span> <span class="token keyword">int</span> sum <span class="token operator">=</span> i <span class="token operator">+</span> j<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 执行一次</span> <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//执行100次</span>     <span class="token comment" spellcheck="true">//</span> <span class="token punctuation">}</span></code></pre><p>$ O(1) $说明只要算法<span style='color:red'>不存在</span><strong>循环语句</strong>，<strong>递归语句</strong>，那么即使有<strong>成千上万</strong>行代码，其<strong>时间复杂度</strong>表示为$  O(1)  $。</p><h3 id="2-O-logn-、O-nlogn"><a href="#2-O-logn-、O-nlogn" class="headerlink" title="2. $ O(logn)、O(nlogn) $"></a>2. $ O(logn)、O(nlogn) $</h3><pre><code> i=1; //执行一次 while (i &lt;= n)  {    i = i * 2; //执行2^n次 }</code></pre><p>这个比较难理解，看下图:</p><p><img src="https://static001.geekbang.org/resource/image/9b/9a/9b1c88264e7a1a20b5954be9bc4bec9a.jpg" alt="指数增长"></p><p>由这个图我们可以得到$ n = 2 ^ x$那么我们解$ x $得到$ x = log_2n $,那么上面那段代码的<strong>时间复杂度</strong>就是$ O(log_2n) $。</p><pre class=" language-c"><code class="language-c"> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span>  <span class="token punctuation">{</span>   i <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>由这个例子我们可以得到$ n = 3 ^ x $也就是解$ x $可以得到$ x = log_3n $，那么这段代码的<strong>时间复杂度</strong>就是$ O(log_3n) $；<strong>但是</strong>，由于<strong>对数</strong>可以相互转化所以这里都简写成$ O(logn) $了。</p><pre><code>int cat(int n){ int sum = 0; for(int i = 0 ; i &lt; n ; i++){     sum = sum + f(i); }}int f(int n){    int i = 1;    while(i &lt;= n){        i = i * 2;    }}</code></pre><p>上面我们知道<strong>乘法法则</strong>，那么$ O(nlogn) $就很好理解了，上面的代码<strong>函数</strong>$ f(n) $执行了$ O(logn) $,在<strong>函数</strong>$ cat(n) $中 <code>sum = sum + f(i)</code>这里就知道了<br>$$<br>O(n) = O_c(n) <em> O_f(n) = O(n) </em> O(logn) = O(nlogn)<br>$$</p><h3 id="3-O-m-n-、O-m-n"><a href="#3-O-m-n-、O-m-n" class="headerlink" title="3. $ O(m+n)、O(m*n) $"></a>3. $ O(m+n)、O(m*n) $</h3><pre><code>int cal(int m, int n) {  int sum_1 = 0; //这里执行1次  int i = 1; //这里执行1次  for (; i &lt; m; ++i) { //这里执行m次    sum_1 = sum_1 + i; //这里执行m次  }  int sum_2 = 0; //这里执行1次  int j = 1; //这里执行1次  for (; j &lt; n; ++j) { //这里执行n次    sum_2 = sum_2 + j; //这里执行n次  }  return sum_1 + sum_2;}</code></pre><p>上面的这段代码我们可以看到有<strong>两个</strong>循环结构他们循环的次数<strong>各不相同</strong>一个是<strong>n</strong>次还有一个是<strong>m</strong>次，因为无法<strong>事先评估</strong>m和n的次数，所以计算这种<strong>时间复杂度</strong>的时候，我们得出的结果为:<br>$$<br>O(N) = O(m) + O(n) = O(m+n)<br>$$<br>对于$ O(m * n) $其实就很容易了，可以参考下面的代码：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">cal</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//这里执行1次</span>   <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这里执行 1 次</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//这里执行m次</span>     ret <span class="token operator">=</span> ret <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这里执行m次</span>   <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//这一段代码执行最多的表示 n 次 那么 表示 O(n)</span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这里执行1次</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这里执行1次</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//这里执行 n 次</span>    sum <span class="token operator">=</span> sum <span class="token operator">+</span> i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这里执行 n 次</span>  <span class="token punctuation">}</span>   <span class="token keyword">return</span> sum<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这里执行1次</span>  <span class="token comment" spellcheck="true">//那么这一段代码中最多的执行为 n 次 那么 表示 O(n)</span> <span class="token punctuation">}</span></code></pre><p>这里我们可以计算得到：<br>$$<br>O(N) = O(m) <em> O(n) = O(m</em>n)<br>$$</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>由于<strong>空间复杂度</strong>和<strong>时间复杂度</strong>基本上类似，所以这里给出一个定义<strong>表示算法的存储空间与数据规模之间的增长关系</strong>,全称<strong>渐进空间复杂度</strong>。</p><p>比如 <code>int [] a = new int[n]</code>那么这段就说明<strong>空间复杂度</strong>为$ O(n) $。</p><h2 id="复杂度的比较图"><a href="#复杂度的比较图" class="headerlink" title="复杂度的比较图"></a>复杂度的比较图</h2><p><img src="https://static001.geekbang.org/resource/image/49/04/497a3f120b7debee07dc0d03984faf04.jpg" alt="复杂度比较图"></p><h1 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h1><h2 id="你为什么要学习数据结构和算法呢？"><a href="#你为什么要学习数据结构和算法呢？" class="headerlink" title="你为什么要学习数据结构和算法呢？"></a>你为什么要学习数据结构和算法呢？</h2><p>作为一个学生党，对于数据结构和算法的了解仅仅只是在蓝桥杯比赛中实际运用过，但是听过很多前辈与学长的教诲都说明了其重要性，前段时间买了慕课网的一门课程，在学习时知道这些基础的知识对编程的原理掌握以及看懂开源框架十分的重要，因此要花费时间学习这些知识。</p><h2 id="在过去的软件开发中，数据结构和算法在哪些地方帮到了你？"><a href="#在过去的软件开发中，数据结构和算法在哪些地方帮到了你？" class="headerlink" title="在过去的软件开发中，数据结构和算法在哪些地方帮到了你？"></a>在过去的软件开发中，数据结构和算法在哪些地方帮到了你？</h2><p>对于这个问题，作为一个学生其实这个对我的帮助并不多，因为我没参加过实际的项目开发，也不懂得实际的项目开发经验，现在唯一给我帮助的地方就只有当时参加<strong>蓝桥杯</strong>比赛，让我从比赛中获得了<strong>省赛一等</strong>的成绩，为后面申请<strong>国家奖学金</strong>给了一些帮助。</p><h2 id="项目运行时会做性能测试，我们有必要进行时间与空间的复杂度分析呢？"><a href="#项目运行时会做性能测试，我们有必要进行时间与空间的复杂度分析呢？" class="headerlink" title="项目运行时会做性能测试，我们有必要进行时间与空间的复杂度分析呢？"></a>项目运行时会做性能测试，我们有必要进行时间与空间的复杂度分析呢？</h2><p>虽然项目运行的时候会进行性能相关的测试，但是我们也有必要进行相关的时间与空间复杂度分析，我们可以对一些及其影响性能的功能代码进行分析，因为这些代码对性能要求极高，越节省对后面跑大规模的数据越有利。</p><h2 id="对每段代码分析时间与空间复杂度，是否会浪费时间？"><a href="#对每段代码分析时间与空间复杂度，是否会浪费时间？" class="headerlink" title="对每段代码分析时间与空间复杂度，是否会浪费时间？"></a>对每段代码分析时间与空间复杂度，是否会浪费时间？</h2><p>对每段代码的分析，可能浪费时间了，因为并不是每段代码都涉及到大量的操作，可能有些代码并不常执行，因此对一些重要的代码可以进行时间与空间的复杂度分析，毕竟有一个工种就叫算法工程师，虽然他们大部分可能涉及代码研究，但是对于一些代码的优化也是他们工种的工作内容之一。</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法之美 </tag>
            
            <tag> 极客时间 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用Git</title>
      <link href="/archives/ab8e450c.html"/>
      <url>/archives/ab8e450c.html</url>
      
        <content type="html"><![CDATA[<!-- 这里注释一上面可能常用的东西 --><!-- toc用于目录的展开默认无需更改 --><!-- tags与categories 一个是标签一个是文章分类 标签可以有多个 文章分类只能有一个 要注意 直接后面添加即可 --><!-- top 默认 false 这个是用来推荐文章的 --><!-- mathjax 默认是 false 如果以后要用到数学公式可以开启 --><!-- summary 写得是关于文章的摘要 --><!-- password用于对文章进行加密 这里需要利用SHA256算法加密 这里给个加密网址  https://tool.oschina.net/encrypt?type=2 --><h1 id="相关软件"><a href="#相关软件" class="headerlink" title="相关软件"></a>相关软件</h1><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>Git是一个开源分布式版本控制系统，简单来说就如同<strong>系统备份</strong>可以备份你写的代码，并且可以回溯你之前的代码。</p><h2 id="SourceTree"><a href="#SourceTree" class="headerlink" title="SourceTree"></a>SourceTree</h2><p>SourceTree是一个<strong>图形化</strong>的Git客户端，简单来说就是能够让我们通过像操作Windows那样更加容易的完成自己的代码版本控制。</p><h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h2><p>Git的下载需要到其官网下载，这里给出其Windows版本的链接<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Git For Windows</a>，直接点击<strong>Click here to download manually</strong>即可下载适合自己版本的Git,至于安装无脑下一步即可。</p><h2 id="SourceTree安装"><a href="#SourceTree安装" class="headerlink" title="SourceTree安装"></a>SourceTree安装</h2><p>SourceTree的下载同样在其<a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">官方网站</a>能够下载到，由于我自己已经安装了SourceTree所以这里给出<a href="https://www.jianshu.com/p/dce21c4e88fc" target="_blank" rel="noopener">SourceTree安装（小白特别详细教程）</a>。</p><h1 id="创建属于自己的远程仓库"><a href="#创建属于自己的远程仓库" class="headerlink" title="创建属于自己的远程仓库"></a>创建属于自己的远程仓库</h1><ol><li>在创建自己的远程仓库之前，我们需要拥有自己的GitHub账号，登录 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>既可以创建，这里推荐<strong>谷歌浏览器</strong>因为其自带翻译功能，毕竟对于新手来说，英语也是一个门槛，在完成自己账号的创建登录之后选择上方的<strong>加号</strong>，选择<strong>New repository</strong>  </li></ol><p><img src="https://s1.ax1x.com/2020/07/11/UQEHaQ.png" alt="UQEHaQ.png"></p><ol start="2"><li>跳转页面后在<strong>Repository name</strong>中填入自己的仓库名，<strong>Description</strong>中填入对此仓库的描述，这里注意的是由于初期我们使用的是<strong>SourceTree</strong>因此勾选<strong>Initialize this repository with a README</strong>可以减少对仓库的初始化操作，交由Github完成，最后点击<strong>Create repository</strong>即可创建自己的GitHub远程仓库。</li></ol><p><img src="https://s1.ax1x.com/2020/07/11/UQEoqS.png" alt="UQEoqS.png"></p><ol start="3"><li>创建完成后，选择<strong>Code</strong>按钮，在<strong>Clone With HTTPS</strong>中会给出一个<strong>URL</strong>链接，复制这个链接即可。<br>Note:当然这里也可以选择<strong>Use SSH</strong>,通过SSH密钥的方式登入，这里不做赘述。</li></ol><p><img src="https://s1.ax1x.com/2020/07/11/UQE7Vg.png" alt="UQE7Vg.png"></p><ol start="4"><li>在本地打开我们的<strong>SourceTree</strong>按住<strong>Ctrl+N</strong>打开一个页面，选择上方的<strong>Clone</strong>填入<strong>URL</strong>以及<strong>本地保存路径</strong>点击<strong>克隆</strong>即可</li></ol><p><img src="https://s1.ax1x.com/2020/07/11/UQEIr8.png" alt="UQEIr8.png"></p><h1 id="相关引用与推荐"><a href="#相关引用与推荐" class="headerlink" title="相关引用与推荐"></a>相关引用与推荐</h1><ol><li><a href="https://blog.csdn.net/qq_38232598/article/details/91346392" target="_blank" rel="noopener">解决Github网页上图片显示失败的问题</a></li><li><a href="https://www.jianshu.com/p/11bba2b1e95d" target="_blank" rel="noopener">SourceTree 入门教程</a></li><li><a href="https://blog.csdn.net/weixin_38419133/article/details/89412755?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-8.edu_weight&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-8.edu_weight" target="_blank" rel="noopener">如何在Github 的README.md文件中添加图片</a></li><li><span style='color:red'> *强烈推荐 </span>  <a href="https://www.imooc.com/learn/1052" target="_blank" rel="noopener">Git入门</a> <em>这个教程里面有Git命令方法与SourceTree使用方法，开始可以挑选SourceTree的方法</em></li><li><span style='color:red'> *强烈推荐 </span> <a href="https://mp.weixin.qq.com/s?__biz=MzU4NTIxODYwMQ==&mid=2247483856&idx=1&sn=47a72cee1190aefc06c24fea78f78484&chksm=fd8cae96cafb2780f2634bbeece1608f321ea2698523869ff6d0c58497ad2dfbf5fa1233b0dd&token=88683563&lang=zh_CN#rd" target="_blank" rel="noopener">天生不聪明</a> <em>大牛的软文，可以看看参考一哈，也是本课程的作者</em></li><li><span style='color:red'> *强烈推荐</span> <a href="https://mp.weixin.qq.com/s?__biz=MzU4NTIxODYwMQ==&mid=2247483836&idx=1&sn=90854aa76507281403e4dd9cd434a12b&chksm=fd8caefacafb27ec78f999fde4f1217c04c6e2ff28cf51fe511d8fa29d484d9281ff91de8c9c&token=88683563&lang=zh_CN#rd" target="_blank" rel="noopener">如果高效学习有什么秘诀的话，那就都在这里了</a> <em>同上</em></li></ol><h1 id="后续补充-–-这里是后续会补充的内容-当然暂时是不会补充了"><a href="#后续补充-–-这里是后续会补充的内容-当然暂时是不会补充了" class="headerlink" title="后续补充 – 这里是后续会补充的内容 当然暂时是不会补充了"></a>后续补充 – 这里是后续会补充的内容 <del>当然暂时是不会补充了</del></h1><ol><li>markdown的使用与安装</li><li>如何使用GitBush进行操作</li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> Git </tag>
            
            <tag> SourceTree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github+Hexo搭建博客教程</title>
      <link href="/archives/19f3ab51.html"/>
      <url>/archives/19f3ab51.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为毕业了，所以为了以后能够有一个记录的博客，所以花费了一段时间，搭建了一个利用GitHub+Hexo实现的个人博客<del>(最大的原因是因为可以白嫖)</del> ，但是之前使用的博客没有用过Markdown进行相关的内容写作，因此教程可能有些地方并不美观，还请各位小伙伴能够见谅，有问题也可以在下方留言，有时间我会回答的。</p><p>首先我们要了解一下我们搭建博客需要使用的框架Hexo，这个框架是一个高效的静态站点生成框架，基于Node.js。通过这个框架我们可以利用MarkDown语法来撰写自己的博客内容，并且写文章，除了没有可视化管理界面以外一切都很方便(这个问题可以用插件解决)，废话少说下面介绍。</p><h1 id="准备与安装"><a href="#准备与安装" class="headerlink" title="准备与安装"></a>准备与安装</h1><p>在这搭建自己的博客之前我们需要完成三个主要的步骤，首先要拥有你自己的<strong>Github账号</strong>其次要在你的系统中安装好<strong>Git</strong>以及<strong>Node.js</strong>。</p><h2 id="Github的注册"><a href="#Github的注册" class="headerlink" title="Github的注册"></a>Github的注册</h2><p><a href="https://www.github.com" target="_blank" rel="noopener">Github</a> 的注册网上有很多的教程，由于我自己已经有了一个Github账号，因此这里给出网上比较新的注册教程，虽然GIthub网站是英文的网站，但是一般的浏览器都自带翻译功能，相信这个难不倒各位————<a href="https://blog.csdn.net/JCtry/article/details/107191143" target="_blank" rel="noopener">Gihub注册教程</a></p><h2 id="Git的安装"><a href="#Git的安装" class="headerlink" title="Git的安装"></a>Git的安装</h2><p>因为我们需要把自己本地仓库的内容上传到Github上面去，所以我们可能需要用到版本控制工具<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a>，由于这个工具并不是GUI工具所以可能需要学习一些命令，本文需要用到的命令下面都会标出，这里同样给出一个<a href="https://blog.csdn.net/aiwst/article/details/106924863" target="_blank" rel="noopener">Git的安装教程</a>照着安装即可。</p><p><strong>Note：</strong></p><p>​    这里提示一下，添加路径的时候要选择 <code>Use Git from the Windows Command Prompt</code>,这样做的好处可以让我们在Windows的控制台打开Git。安装完成之后Windows系统下按住<code>Win+R</code>输入<code>cmd</code>打开控制台输入<code>git --version</code>验证是否安装成功，效果如下图：</p><img src="https://s1.ax1x.com/2020/07/10/UuXJvq.png" alt="UuXJvq.png" style="zoom:85%;" /><h2 id="Node-js的安装"><a href="#Node-js的安装" class="headerlink" title="Node.js的安装"></a>Node.js的安装</h2><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>安装就比较简单了直接点击<a href="https://nodejs.org/dist/v12.18.2/node-v12.18.2-x64.msi" target="_blank" rel="noopener">下载</a>其实就可以了，我这里给出的是长期支持的x64版本如果需要其他版本可以上官网查看，安装只需要一路Next即可。</p><p>安装完成之后Windows系统下按住<code>Win+R</code>输入<code>cmd</code>打开控制台,输入 <code>node -v</code> 和 <code>npm - v</code> ,如果出现版本号，就安装成功了，如下图：</p><p><img src="https://s1.ax1x.com/2020/07/10/UuXfaD.png" alt="UuXfaD.png"></p><p>当上面的步骤完成之后，我们就可以开始利用我们的Github搭建我们自己的免费博客了！</p><h1 id="GithubPage设置"><a href="#GithubPage设置" class="headerlink" title="GithubPage设置"></a>GithubPage设置</h1><h2 id="GithubPage仓库创建"><a href="#GithubPage仓库创建" class="headerlink" title="GithubPage仓库创建"></a>GithubPage仓库创建</h2><p>GithubPage是Github提供的一个搭建博客的功能，利用这个我们可以免费搭建属于自己的个人博客，打开<a href="https://github.com" target="_blank" rel="noopener">https://github.com</a> ,新建一个项目，如图所示：</p><p><img src="https://s1.ax1x.com/2020/07/10/UujmW9.png" alt="UujmW9.png"></p><p>之后输入自己的项目名字，项目名为 <code>创建的用户名.github.io</code> 注意的是这里的 <code>.github.io</code> 不能少，同样的你的用户名必须和你的<strong>Github用户名</strong>完全一致，不能改动，例如我这里的账号叫 <code>PertalDemoTest</code> ,那么我创建的 <code>repository</code> 名称就叫 <code>PertalDemoTest.github.io</code> , 下面的 <code>Description</code> 用来填写对这个仓库的描述，其他默认即可，当然这里可以<strong>勾选</strong><code>Initialize this repository with a ReADME</code>，这样可以直接初始化，这里我就不勾选了。</p><p><img src="https://s1.ax1x.com/2020/07/10/UKSBcj.png" alt="UKSBcj.png"></p><p>创建完成之后，出现的界面如下所示:</p><img src="https://s1.ax1x.com/2020/07/10/UKSqUK.png" alt="UKSqUK.png" style="zoom:50%;" /><p>到这里基本的仓库创建就完成了。</p><h2 id="如何利用Git进行初始化"><a href="#如何利用Git进行初始化" class="headerlink" title="如何利用Git进行初始化"></a>如何利用Git进行初始化</h2><p>完成了仓库的创建之后，我们需要对我们自己新建的这个仓库进行一个初始化，这里首先在本地新建一个文件夹用来保存后续上传到仓库的配置，对文件夹<strong>鼠标右键</strong>后选择<strong>Git Bash Here</strong>弹出Git的界面后，我们首先进行c初始化输入 <code>git init</code> 之后一下设置用户名和邮箱的设置，这里分别输入 <code>git config user.name &quot;你的Github用户名&quot;</code> 和 <code>git config user.email &quot;你创建的Github账户邮箱&quot;</code> 当然 如果你只有一个账户的话可以直接设置 <code>git config --global user.name &quot;你的Github用户名&quot;</code>和 <code>git config --global user.email &quot;你创建的Github账户邮箱&quot;</code> 设置完成。</p><p><img src="https://s1.ax1x.com/2020/07/10/UKPWZR.png" alt="UKPWZR.png"></p><p>这里我们使用<strong>SSH</strong>的登入方式，因为这种登录方式比较简单，直接输入 <code>ssh-keygen -t rsa -C &quot;你的电子邮箱&quot;</code>即可，然后一路回车，如果碰到有<strong>(y/n)</strong>打一个<strong>y</strong>继续回车，这样我们就生成了自己的SSH密钥。</p><p><img src="https://s1.ax1x.com/2020/07/10/UKimWT.png" alt="UKimWT.png"></p><p>然后打开你的Github找到<strong>Settings</strong>，找到<strong>SSH and GPG keys</strong>点击<strong>New SSH key</strong>之后到你的 <code>C:/用户/你的用户名/.ssh</code>下找到<code>id_rsa.pub</code>文件利用<strong>记事本</strong>打开复制里面的内容，放入刚刚的页面中，这里的<strong>Title</strong>可以随意，如下图所示：</p><p><img src="https://s1.ax1x.com/2020/07/10/UKkSKg.png" alt="UKkSKg.png"></p><p><img src="https://s1.ax1x.com/2020/07/10/UKATAA.png" alt="UKATAA.png"></p><p>同时这里设置一下，可能需要输入一下自己的密码，验证一下，之后我们在控制台中输入 <code>ssh -T git@github.com</code> 出现下图提示就成功了。</p><p><img src="https://s1.ax1x.com/2020/07/10/UKZxBD.png" alt="UKZxBD.png"></p><p>需要注意的是后面提示没有提供<strong>shell access</strong>这里我们需要在个人账户的设置中找到<strong>Email</strong>设置下将<strong>Keep my email address private</strong>的勾选取消，然后在<strong>Profile</strong>设置中找到<strong>Public email</strong>选择自己的邮箱拉到下面点击<strong>Update profile</strong>解决后面<strong>无法push</strong>的问题。</p><p>接下来我们可以参照<strong>Github的提示</strong>测试一下连接我们的远程仓库</p><p><img src="https://s1.ax1x.com/2020/07/10/UKmjTe.png" alt="UKmjTe.png"></p><p><a href="https://imgchr.com/i/UKnmfs" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/10/UKnmfs.png" alt="UKnmfs.png"></a></p><p>之后刷新一下我们的仓库，可以看到一个<code>README.md</code>文件，到这里我们已经完成了本地与远程仓库的连接。</p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>接下来，刷新一下我们的仓库页面，找到<strong>Settings</strong>下拉找到<strong>GitHub Pages</strong>点击<strong>Choose a theme</strong>选择一个喜欢的主题，选择<strong>Select theme</strong>然后在网址框中输入<code>你的用户名.github.io</code>可以发现已经有一个页面的雏形了。</p><p><img src="https://s1.ax1x.com/2020/07/10/UKuZDK.png" alt="UKuZDK.png"></p><p>接下来我们就开始安装Hexo,在Git控制台中输入 <code>npm i hexo-cli -g</code> ，可能会有<strong>WARN</strong>这里可以直接无视，接下来输入 <code>hexo init</code> 进行初始化，然后输入 <code>npm install</code> 安装必备组件，这里可能有报错，我们可以将隐藏的 <code>.git</code>先移到别处删除我们刚刚创建的<code>REAMD.md</code>文件,等待安装结束后在移回来，接下来我们输入 <code>hexo g</code> 和 <code>hexo s</code> 然后浏览器输入<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> , 就可以看到我们的博客啦，效果如下：</p><p><img src="https://s1.ax1x.com/2020/07/10/UK1iXn.png" alt="UK1iXn.png"></p><p>到这里整个博客就算搭建完成了，接下来我们就可以写我们自己的文章了。</p><h1 id="写文章，发布文章"><a href="#写文章，发布文章" class="headerlink" title="写文章，发布文章"></a>写文章，发布文章</h1><p>首先安装一个扩展 <code>npm i hexo-deployer-git</code> 然后输入 <code>hexo new &quot;文章名&quot;</code>就可以创建一篇文章啦，之后打开 <code>根目录/source/_posts</code>里面就可以发现创建好的文章，这里编写文章可能需要学习一下MarkDown，并且下载一个支持<code>.md</code>文件的程序，这里我用的是<a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a>,当然市面还有其他各类的软件，这里就看个人喜好进行选择了，编写完成后 打开<strong>根目录</strong>下的 <code>_config.yml</code> 文件修改<strong>deploy</strong>后保存。</p><pre><code>deploy:  type: git  repository: https://github.com/你的github用户名/你的github用户.github.io  branch: master</code></pre><p> <code>hexo g</code> 生成文件然后<code>hexo d</code>就可以将自己的文章发布到网站上了，输入 <code>用户名.github.io</code> 就可以访问自己刚刚生成的文章了，到这里基本的博客就搭建完成了。</p><h1 id="个性化设置"><a href="#个性化设置" class="headerlink" title="个性化设置"></a>个性化设置</h1><p>这里埋一个坑，内容很多，慢慢填坑…</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生命不息,折腾不止.---记我自己的路</title>
      <link href="/archives/83a0a85.html"/>
      <url>/archives/83a0a85.html</url>
      
        <content type="html"><![CDATA[<p>​    呼，花了两天的时间，终于用GithubPages和Hexo完成了自己个人博客的搭建，其实之前的三年也搭建过不止一次博客，但是最后都不了了之。原因也很简单，就是觉得写博客很烦，维护博客并且找到心仪的博客主题很难，其实更多的还是自己懒，懒得让自己一直都呆在舒适圈内，一直跌跌撞撞的在徘徊的路上。从自己开始学习编程到现在其实已经过去了6年多了，但是这6年我并没有做出什么拿的出手的项目，也并没有精通一门语言: Python, C/C++, C#, Java 其中除了Java是最近一段时间学习的以外其他都只是在门外打转。买了一堆书，发了一堆誓，打了多次的鸡血，最后泄气之后一事无成，人生好像就是这样起起伏伏的样子，也是因为这样不断的重复，不断的经历，我慢慢不再追求那种完美，开始听信别人的话。</p><p>​    固执，钻牛角，随意答应别人的请求而不去执行，这个毛病在这几年内多次给了我教训，但是每次教训之后我这鱼一样的记忆力让我再次重蹈覆辙，就这样一晃三年过去，我毕业了同样也升学了，大专三年，给我带来了很多的感触也让我确定了自己的人生目标，所以每个时刻的自己真的有着不同的想法，不同的感悟。</p><p>​    现在作为一个还有假期的学生，在此时此刻我写下了自己的一点感慨，其实都算不上感慨，只是自己一时间的想法罢了，毕竟未来我很期待，但是同样的未来的自己又如何，我也不清楚，但是就如同标题一样，我希望未来的自己，生命不息，折腾不止，走出自己的路。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录感悟 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
